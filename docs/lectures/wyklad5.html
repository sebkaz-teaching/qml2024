<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Algorytmy kwantowego uczenia maszynowego QML – Wstęp do kwantowego uczenia maszynowego</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-3f13cc09417cf69baaf74afa0e2e3cf6.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../style.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Wstęp do kwantowego uczenia maszynowego</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../sylabus.html"> 
<span class="menu-text">Sylabus</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../ksiazki.html"> 
<span class="menu-text">Książki</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../lectures/wyklad1.html">Wykłady</a></li><li class="breadcrumb-item"><a href="../lectures/wyklad5.html">Algorytmy kwantowego uczenia maszynowego QML</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Informacje ogólne</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../info.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Narzędzia</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Wykłady</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Wprowadzenie do uczenia maszynowego</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bramki logiczne</span></a>
  </div>
</li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false">
 <span class="menu-text">ćwiczenia do W2</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/cw_w2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Modele uczenia maszynowego</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad5.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Algorytmy kwantowego uczenia maszynowego QML</span></a>
  </div>
</li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="false">
 <span class="menu-text">ćwiczenia do W5</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/cw_w5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Trenowanie sieci neuronowej PyTorch</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Ćwiczenia</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../labs/cw1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Obliczenia hybrydowe</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../labs/cw2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Pennylane wprowadzenie</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../labs/cw3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bramki jednokubitowe</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../labs/cw4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bramki wielokubitowe</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../labs/cw5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Optymalizacja z Variational Quantum Algorithms</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../labs/cw6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Przykłady prostych modeli uczenia maszynowego</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#parameterised-quantum-circuit-jak-ogólny-model-uczenia-maszynowego" id="toc-parameterised-quantum-circuit-jak-ogólny-model-uczenia-maszynowego" class="nav-link active" data-scroll-target="#parameterised-quantum-circuit-jak-ogólny-model-uczenia-maszynowego">Parameterised Quantum Circuit jak ogólny model uczenia maszynowego</a></li>
  <li><a href="#quantum-neural-networks" id="toc-quantum-neural-networks" class="nav-link" data-scroll-target="#quantum-neural-networks">Quantum Neural Networks</a></li>
  <li><a href="#modele-generatywne" id="toc-modele-generatywne" class="nav-link" data-scroll-target="#modele-generatywne">Modele generatywne</a></li>
  <li><a href="#kodowanie-danych" id="toc-kodowanie-danych" class="nav-link" data-scroll-target="#kodowanie-danych">Kodowanie danych</a>
  <ul class="collapse">
  <li><a href="#basis-encoding" id="toc-basis-encoding" class="nav-link" data-scroll-target="#basis-encoding">Basis encoding</a></li>
  <li><a href="#amplitude-encoding" id="toc-amplitude-encoding" class="nav-link" data-scroll-target="#amplitude-encoding">Amplitude encoding</a></li>
  <li><a href="#angle-encoding" id="toc-angle-encoding" class="nav-link" data-scroll-target="#angle-encoding">Angle Encoding</a>
  <ul class="collapse">
  <li><a href="#schemat-kodowania" id="toc-schemat-kodowania" class="nav-link" data-scroll-target="#schemat-kodowania">Schemat kodowania</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#ansatz-i-schematy-modelowe" id="toc-ansatz-i-schematy-modelowe" class="nav-link" data-scroll-target="#ansatz-i-schematy-modelowe">Ansatz i schematy modelowe</a></li>
  <li><a href="#pomiar-i-interpretacja-wyników" id="toc-pomiar-i-interpretacja-wyników" class="nav-link" data-scroll-target="#pomiar-i-interpretacja-wyników">Pomiar i interpretacja wyników</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../lectures/wyklad1.html">Wykłady</a></li><li class="breadcrumb-item"><a href="../lectures/wyklad5.html">Algorytmy kwantowego uczenia maszynowego QML</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Algorytmy kwantowego uczenia maszynowego QML</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><img src="../img/classicalML.png" class="img-fluid"></p>
<p><span class="math display">\[
\newcommand{\bra}[1]{\left \langle #1 \right \rvert}
\newcommand{\ket}[1]{\left \rvert #1 \right \rangle}
\newcommand{\braket}[2]{\left \langle #1 \middle \rvert #2 \right \rangle}
\]</span></p>
<p>Komputery kwantowe nie są jeszcze maszynami, które moglibyśmy wykorzystać do codziennych zadań. Dostępne komputery kwantowe pozwalają wykonywać algorytmy i obliczenia na około 100 kubitach. Nie posiadają one jednak mechanizmu korekcji błędów. Ponadto, bramki muszą działać znacznie szybciej niż ich czas dekoherencji, co uniemożliwia realizację długich sekwencji bramek dla złożonych algorytmów. Dlatego obecny etap rozwoju tych maszyn nazywany jest erą <strong>NISQ</strong>(ang. <em>Noisy Intermediate-Scale Quantum</em>)</p>
<p>Pomimo ograniczeń technologicznych, wciąż można wykazać tzw. kwantową supremację (czyli przewagę algorytmów kwantowych nad klasycznymi) w problemach optymalizacyjnych i w modelowaniu danych wykorzystując do tego celu parametryzowane obwody kwantowe (ang. <em>Parameterized quantum circuits</em>, PQCs), które z wykorzystaniem klasycznych optymalizatorów mogą być trenowane w celu znalezienia optymalnych wartości dla zadanej funkcji kosztu. Podejście takie nazywane jest <strong>uczeniem hybrydowym</strong>.</p>
<p>PQC realizowane są z wykorzystaniem bramek w postaci ustalonej (np. bramki CNOT). Wykorzystują one również bramki parametryzowane, co pozwala generować nietrywialne wyniki. Algorytmy przystosowane do realizacji na obecnych komputerach kwantowych nazywamy algorytmami NISQ.</p>
<p>Modele kwantowego uczenia maszynowego (ang. <em>Quantum Machine Learning</em>, <strong>QML</strong>) realizowane przez kwantowe algorytmy wariacyjne (ang. <em>Variational Quantum Algorithms</em>, <strong>VQA</strong>) reprezentują całą klasę algorytmów, które używają klasycznych optymalizatorów do znalezienia parametrów kwantowych obwodów. Szczególnymi realizacjami tak zdefiniowanych modeli są:</p>
<ul>
<li>Variational Quantum Eigensolver</li>
<li>Variational Quantum Solvers</li>
<li>Variational Quantum Classifier</li>
<li>Quantum Support Vector Classification</li>
<li>Quantum Neural Networks</li>
<li>Quantum Autoencoder</li>
<li>Quantum Approximate Optimization Algorithm</li>
</ul>
<p>Postaramy się zdefiniować jakie problemy i modele możemy sformułować tak by nie wymagały one duzej liczby (zaszumionych) kubitów.</p>
<p>Cały obwód kwantowy moze być kontrolowany za pomocą parametrów realizowanych w bramkach. Mozna go traktować jako <strong>rózniczkowalną funkcję</strong>.</p>
<p>Automatyczne rózniczkowanie wykorzystywane jest w paradygmacie programowania <a href="https://en.wikipedia.org/wiki/Differentiable_programming">Differentiable programming</a> jak równiez w szeroko stosowanych sieciach neuronowych. Podejście to mozna wyrazic jako coś więcej niz sieci neuronowe. To paradygmat gdzie algorytmy nie są kodowane ale <strong>uczące się</strong>.</p>
<section id="parameterised-quantum-circuit-jak-ogólny-model-uczenia-maszynowego" class="level2">
<h2 class="anchored" data-anchor-id="parameterised-quantum-circuit-jak-ogólny-model-uczenia-maszynowego">Parameterised Quantum Circuit jak ogólny model uczenia maszynowego</h2>
<p>Wiemy juz jak składać bramki w celu utworzenia dowolnego (i o dowolnej głębokości) obwodu. <span class="math display">\[ \ket{\psi'} = U_m(\theta_m)\dots U_2(\theta_2) U_1(\theta_1) \ket{\psi} \]</span></p>
<p>Część indywidualnych bramek (ze zbioru <span class="math inline">\((U_i)_{i=1,/dots,m}\)</span>) moze być ustalona np. <span class="math inline">\(X\)</span>, <span class="math inline">\(CNOT\)</span>, czyli ich parametry są ściśle określone (np. <span class="math inline">\(\pi\)</span>). Jednak część bramek moze zalezeć od parametrów obrotów wyrazonych najczęściej jako radiany (w zakresi <span class="math inline">\(\theta \in [-\pi, \pi]\)</span>). Po przygotowaniu stanu <span class="math inline">\(\ket{\psi'}\)</span> mozemy zmierzyć jeden lub cały zestaw kubitów. Po pomiarze kubity zostają w stanie bazowym zgodnie z wykorzystanym operatorem. Najczęściej wybieramy bazę obliczeniową pozwalającą uzyskać rezultat jako listę bitów.</p>
<p>Tak zdefiniowany i działający obwód kwantowy mozna wykorzystać do wielu rzeczy. Dla nas najwazniejszym aspektem jest mozliwość trenowania parametrów obwodu.</p>
<p><img src="../img/proces.png" class="img-fluid"></p>
<!-- ## Variational Quantum Eigensolver
PQC uzywany jest do wygenerowania końcowego stanu $\ket{\psi'}$, który jest bliski stanowi odpowiadającemu najmniejszej wartości własnej problemu zakodowanego w postaci Hamiltonianiu. Odpowiada to stanowi podstawowemu (o najnizszej energii) powiązanemu z minimum funkcji kosztu. -->
</section>
<section id="quantum-neural-networks" class="level2">
<h2 class="anchored" data-anchor-id="quantum-neural-networks">Quantum Neural Networks</h2>
<p>PQC mozna wykorzystać do tworzenia modelu predykcyjnego - kwantowa sieć neuronowa jako klasyfikator. W tym przypadku dokonuje się pomiaru kilku a nawet jednego kubitu w celu weryfikacji wyniku. Stan początkowy powinien kodować próbkę danych do sklasyfikowania</p>
<p><img src="../img/algo.png" class="img-fluid"></p>
</section>
<section id="modele-generatywne" class="level2">
<h2 class="anchored" data-anchor-id="modele-generatywne">Modele generatywne</h2>
<p>W tym przypadku mozemy zbudować Quantum Circuit Born Machine gdzie dokonujemy pomiaru wszystkich kubitów w celu wygenerowania nowej próbki. Prawdopodobieństwo pojawienia się wartości otrzymanych z próbki zakodowane zostaje w stanie <span class="math inline">\(\ket{\psi'}\)</span>.</p>
</section>
<section id="kodowanie-danych" class="level1">
<h1>Kodowanie danych</h1>
<p>Do zakodowania informacji klasyczne komputery używają bitów (które przyjąć mogą wartość 0 lub 1). Aktualnie używa się systemów, które kodują znaki w postaci 32 lub 64 bitowych sekwencjach. Pozwala to zakodować wszystkie znaki z kodowania ASCII bądź Unicode.</p>
<p>Preprocessing pozwalający załadować wektor danych <span class="math inline">\(x\)</span> do parametrycznego obwodu kwantowego z wykorzystaniem tzw. <em>feature mapy</em>, czyli funkcji <span class="math inline">\(\psi(x)\)</span>. Funkcja ta wyrażana jest jako parametryzowany obwód kwantowy opisany przez operator <span class="math inline">\(U_{\psi(x)}\ket{0}\)</span>.</p>
<p>W tym miejscu warto zwrócić uwagę, iż procedura ta jest podobna do stosowania zanurzeń danych nieustrukturyzowanych w sieciach neuronowych (ang. embedding). Na przykład przetworzenie danych tekstowych z wykorzystaniem algorytmu Word2Vec. W fazie tej bardzo ważnym krokiem jest klasyczne przygotowanie danych poprzez takie elementy jak czyszczenie braków danych, standaryzacja czy też transformacje pozwalające otrzymać odpowiedni rozkład zmiennej.</p>
<p>Istnieje wiele różnych sposobów kodowania (ang. encode) lub zanurzenia (ang. embed) informacji w układ n-kubitów opisany przez stan kwantowy. Ponieważ chcemy użyć kwantowego komputera do uczenia się algorytmu na podstawie klasycznych danych musimy zdecydować w jaki sposób będziemy reprezentować wiersz danych a nawet cały zbiór danych w postaci stanu kwantowego.</p>
<section id="basis-encoding" class="level2">
<h2 class="anchored" data-anchor-id="basis-encoding">Basis encoding</h2>
<p>Jedną ze strategii jest tzw. kodowanie bazowe (ang. basis encoding), które polega na zamianie wektora danych wyrażonego w postaci bitowej na wektory bazowe kubitów (<span class="math inline">\(0\to \ket{0}\)</span> i <span class="math inline">\(1\to \ket{1}\)</span>). Chcąc jednak kodować dużo zmiennych i z dużą precyzją poszczególnych wartości będziemy zmuszeni do wykorzystania bardzo dużej ilości kubitów, co dla obecnych maszyn nie jest zbyt dobrym rozwiązaniem. Kodowanie to, tak samo jak w przypadku bitów, pozwala realizować zarówno liczby całkowite jak i rzeczywiste (dla z góry określonej precyzji).</p>
</section>
<section id="amplitude-encoding" class="level2">
<h2 class="anchored" data-anchor-id="amplitude-encoding">Amplitude encoding</h2>
<p>Układ n-kubitów może być reprezentowany jako superpozycja stanów bazowych. Pozwala to zakodować dane w amplitudach (ang. amplitude encoding). Normalizując wektor danych <span class="math inline">\(x=(x_1,\dots x_{2^k})\)</span> , tak by <span class="math inline">\(\sum_k |x_k|^2 = 1\)</span> możemy zakodować wszystkie <span class="math inline">\(x_k\)</span> jako amplitudy. Na przykład <span class="math display">\[x=(0.073,-0.438,0.730,0.000) \to \ket{x}=0.073\ket{00}-0.438 \ket{01} + 0.730 \ket{10} + 0\ket{11} \]</span></p>
<p>Więcej przykładów <a href="https://pennylane.ai/qml/glossary/quantum_embedding/">kwantowego embeddingu</a></p>
</section>
<section id="angle-encoding" class="level2">
<h2 class="anchored" data-anchor-id="angle-encoding">Angle Encoding</h2>
<p>Każdy kubit moze być opisany przez <strong>dwa</strong> kąty <span class="math inline">\(\theta\in [0,\pi]\)</span> oraz <span class="math inline">\(\phi \in [0,2\pi]\)</span>. Każda wartość opisuje jeden punkt na sferze Blocha. Przetwarza ono zmienne na iloczyny i sumy funkcji cosinus i sinus. W kodowaniu tym istotne jest, aby podczas procesu skalowania zmiennych wyskalować je do wartości <span class="math inline">\((-1,1)\)</span>.</p>
<p><span class="math display">\[
|x⟩ = cos⁡(x_i) \ket{0} + sin⁡(x_i)\ket{1}  
\]</span></p>
<section id="schemat-kodowania" class="level3">
<h3 class="anchored" data-anchor-id="schemat-kodowania">Schemat kodowania</h3>
<p>Rozwazmy N wierszy 8 zmiennych <span class="math inline">\(X_1\dots X_8\)</span> o wartościach rzeczywistych.</p>
<p>Potrzebujemy określić <span class="math inline">\(X_i^{max}\)</span> oraz <span class="math inline">\(X_i^{min}\)</span>.</p>
<p><span class="math inline">\(\theta^j_i = \frac{X^j_i - X_i^{min}}{X_i^{max}-X_i^{min}} \pi\)</span></p>
<p>Korzystając z bramki <span class="math inline">\(R_y\)</span> mozemy zakodować kazdy kubit z osobnym kątem. Mozna takze wybrać dwie bramki z dwoma kątami dla jednego kubitu (<span class="math inline">\(R_y\)</span> i <span class="math inline">\(R_z\)</span>)</p>
</section>
</section>
</section>
<section id="ansatz-i-schematy-modelowe" class="level1">
<h1>Ansatz i schematy modelowe</h1>
<p>Parametryzowany kwantowy obwód wariacyjny reprezentowany przez operator <span class="math inline">\(W_\theta\)</span> zależny od wektora parametrów <span class="math inline">\(\theta\)</span>, który działa na wektor stanu przygotowany przez obwód kodujący dane <span class="math inline">\(W_\theta \ket{\phi}\)</span>, gdzie <span class="math inline">\(\ket{phi}\)</span> przygotowaliśmy za pomocą kodowania danych. Ze względu na bardzo dużą ilość kombinacji bramek, które można łączyć równolegle i szeregowo trudno jest wskazać jeden konkretny obwód pozwalający realizować wszystkie problemy analityczne (nie ma darmowych obiadów). Wybór odbywa się najczęściej poprzez ustalenie różnych schematów i ich trenowania. Porównać można to do klasycznych sieci neuronowych, gdzie ilość warstw ukrytych, liczba neuronów w każdej warstwie czy funkcje aktywacji są tzw. hiper-parametrami, które ustala się przez doświadczenie. Wybrany schemat obwodów kwantowych określa się często mianem ansatzu.</p>
</section>
<section id="pomiar-i-interpretacja-wyników" class="level1">
<h1>Pomiar i interpretacja wyników</h1>
<p>Na tym etapie najczęściej estymuje się zbiór wartości oczekiwanych $_{k=1}^K , przyjmujący wartości od -1 do 1.<br>
W zależności od realizowanego procesu można wykonać pomiar jednego lub większej ilości kubitów. Można również generować wynik w postaci amplitud, prawdopodobieństw czy też wyniku w postaci binarnej. Etap ten często nazywany jest postprocesingiem danych.</p>
<p><img src="../img/Rys3.png" class="img-fluid"></p>
<p>Inny sposób pomiaru</p>
<p><img src="../img/rys6.png" class="img-fluid"></p>
<!-- ## QAOA 

Bramki kwantowe realizowane są w modelu bramkowym przez `operatory unitarne` reprezentowane przez macierze.

$U U^{\dagger} = U^{\dagger} U = I$

Kazda macierz unitarna moze być przedstawiona jako: 

$U(H,t) = e^{-i H t}$

gdzie $H$ to macierz Hermitowska ($H=H^{\dagger}$)

W ogólności, implementacja obwodu kwantowego, który dokładnie realizuje macierz unitarną dla zadanego 
Hamiltonianiu jest bardzo trudnym zadaniem. 
Hamiltonian taki zazwyczaj składa się z sumy wielu niekomutujących części.  

$H = H_1 + H_2 + \dots + H_n$ 

Mozemy wykorzystać wzór  `Trotter'a-Suzuki`, który przybliza dowolną sumę macierzy 
$e^{A + B} \approx \left( e^{A/n} e^{B/n} \right)^n$ 
 
dlatego dla  $H=\sum_k H_k$ otrzymujemy
$ U(H,t,n) = \prod_{j=1}^n \prod_k e^{-i H_k t/n} $ -->


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>