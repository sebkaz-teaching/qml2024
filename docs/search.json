[
  {
    "objectID": "lectures/cw_w5.html",
    "href": "lectures/cw_w5.html",
    "title": "Trenowanie sieci neuronowej PyTorch",
    "section": "",
    "text": "import pennylane as qml\nimport torch\nimport pandas as pd \nimport matplotlib.pyplot as plt\n\nfrom IPython.display import clear_output\n\nN_QUBITS = 2\n\ntorch.manual_seed(1234)\n\n# DANE \n\nx = torch.linspace(0,10,500).view(-1,1)\ny = torch.sin(x)\ny = y + 0.1*(torch.rand(500).view(-1,1)-0.5)\n\nplt.figure(figsize=(8,4))\nplt.plot(x, torch.sin(x).view(-1,1), color=\"tab:grey\", alpha=0.6, label=\"sin(x)\")\nplt.scatter(x,y, label=\"dane treningowe\")\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "check/grover.html",
    "href": "check/grover.html",
    "title": "Klasyfikacja z wykorzystaniem Algorytmu Grovera",
    "section": "",
    "text": "# dane testowe\n\ndef generate_data():\n    data = {'A': [(0.2, 0.5), (0.1, 0.4), (0.4, 0.8)],\n            'B': [(0.7, 0.2), (0.6, 0.3), (0.8, 0.1)]}\n    return data\n\n\ngenerate_data()\n\n\nfrom qiskit import QuantumCircuit, assemble, transpile\nfrom qiskit.visualization import plot_histogram\n\n# Tworzenie obwodu kwantowego dla algorytmu Grovera\ndef grover_circuit():\n\n    qc = QuantumCircuit(2, 2)\n\n    # Inicjalizacja superpozycji równomiernej\n    qc.h([0, 1])\n    qc.barrier()\n    # Faza odwracająca dla klasyfikacji\n    qc.cz(0, 1)\n\n    # Inwersja przez odbicie średniej\n    qc.h([0, 1])\n    qc.z([0, 1])\n    qc.cz(0, 1)\n    qc.h([0, 1])\n\n    return qc\n\nW algorytmie Grovera chodzi o przyspieszenie wyszukiwania w niesortowanym zbiorze danych przy użyciu kwantowego mechanizmu wzmacniania amplitud. W kontekście klasyfikacji, można użyć algorytmu Grovera do znalezienia punktu w przestrzeni danych, który spełnia określone warunki, co pozwoli na przypisanie go do jednej z klas.\nW przykładzie klasyfikacji z algorytmem Grovera:\n\nInicjalizacja superpozycji: Pierwszy krok to stworzenie superpozycji stanów kwantowych, co jest osiągane przez zastosowanie bramki Hadamarda (qc.h()) do wszystkich kubitów.\nFaza odwracająca: Następnie używamy bramki fazowej (w tym przypadku bramki cz) do odwrócenia fazy amplitudy stanu reprezentującego poprawne odpowiedzi.\nInwersja przez odbicie średniej: Kolejnym krokiem jest inwersja amplitudy stanu, co jest osiągane przez zastosowanie bramek Hadamarda, bramek fazowych i bramek cz.\nPomiar wyników: Na końcu dokonujemy pomiaru wszystkich kubitów, co skutkuje otrzymaniem pewnego wyniku, który odpowiada jednemu z możliwych stanów kubitów.\n\nW kontekście klasyfikacji, możemy użyć informacji z wyników pomiarów, aby przyporządkować punkt danych do jednej z klas. Na przykład, w tym przypadku, gdy wynik to ‘00’, punkt jest przypisany do klasy A, a w przeciwnym razie do klasy B.\nW implementacji, funkcja grover_circuit tworzy kwantowy obwód realizujący opisane kroki algorytmu Grovera. W funkcji classify_data, dla każdego punktu danych z danego zbioru, jest on wprowadzany do obwodu kwantowego, a wyniki pomiaru są analizowane w celu przypisania punktu do odpowiedniej klasy.\nWarto zauważyć, że implementacja jest w pełni symulacyjna, a prawdziwe korzyści z algorytmu Grovera można uzyskać na prawdziwym komputerze kwantowym, zwłaszcza w przypadku większych zbiorów danych.\n\n# Klasyfikacja danych przy użyciu algorytmu Grovera\ndef classify_data(data, quantum_circuit):\n    classified_points = {'A': [], 'B': []}\n\n    for category, points in data.items():\n        print(points)\n        for point in points:\n            print(f\"wyniki dla point:  {point}\")\n            # Przygotowanie obwodu kwantowego dla każdego punktu danych\n            qc = QuantumCircuit(2, 2)\n\n            # Wprowadzenie danych do obwodu\n            for idx, coord in enumerate(point):\n                theta = 2 * coord * 3.14159\n                print(f\"theta: {theta} dla coord: {coord}\")\n                qc.u(theta, 0, 0, idx)\n                \n            qc.compose(grover_circuit(), qubits=[0, 1], inplace=True)\n            # Pomiar wyników\n            qc.measure([0, 1], [0, 1])\n            display(qc.draw('mpl'))\n            # Symulacja obwodu\n            backend = Aer.get_backend('qasm_simulator')\n            result = backend.run(qc, shots=1000).result()\n            counts = result.get_counts(qc)\n   \n            # Klasyfikacja wyniku\n            most_frequent_result = max(counts, key=counts.get)\n            if most_frequent_result == '00':\n                classified_points[category].append(point)\n            else:\n                classified_points[category].append(point)\n\n\n    return classified_points\n\n\ndata = generate_data()\nclassified_points = classify_data(data, grover_circuit)"
  },
  {
    "objectID": "check/qaoa.html",
    "href": "check/qaoa.html",
    "title": "QUBO",
    "section": "",
    "text": "Bramki kwantowe realizowane są w modelu bramkowym przez operatory unitarne reprezentowane przez macierze.\n\\[\nU U^{\\dagger} = U^{\\dagger} U = I\n\\]\nKazda macierz unitarna moze być przedstawiona jako:\n\\[\nU(H,t) = e^{-i H t}\n\\] gdzie \\(H\\) to macierz Hermitowska (\\(H=H^{\\dagger}\\))\nW ogólności, implementacja obwodu kwantowego, który dokładnie realizuje macierz unitarną dla zadanego Hamiltonianiu jest bardzo trudnym zadaniem. Hamiltonian taki zazwyczaj składa się z sumy wielu niekomutujących części.\n\\[\nH = H_1 + H_2 + \\dots + H_n\n\\]\nMozemy wykorzystać wzór Trotter'a-Suzuki który przybliza dowolną sumę macierzy \\[\ne^{A + B} \\approx \\left( e^{A/n} e^{B/n} \\right)^n\n\\]\ndlatego dla \\(H=\\sum_k H_k\\) otrzymujemy \\[ U(H,t,n) = \\prod_{j=1}^n \\prod_k e^{-i H_k t/n} \\]\n\nQUBO\nKombinatoryczne problemy opytmalizacyjne realizowane są na wielu płaszczyznach naukowych i aplikacyjnych:\n\nlogistyka,\nplanowanie,\noptymalizacja portfolio,\n…\n\nCombinatorial optimization problems are problems involving a large number of yes/no decisions with each set of decisions yielding a corresponding objective function value, like a cost or profit value.\nBecause of the combinatorial explosion of the solution space with the number of variables, finding good solutions is extremely difficult.\nThe QUBO model unifies a rich variety of NP-hard combinatorial optimization problems:\n\nQuadratic Assignment Problems\nCapital Budgeting Problems\nTask allocation Problems\nMaximum–Cut Problems\n\nQUBO objective function:\n\\[\nF(q) = \\sum_a v_a q_a + \\sum_{a &lt; b} \\omega_{a b} q_a q_b\n\\] gdzie \\(q_a \\in \\{0,1\\}\\), \\(v_a\\) oraz \\(\\omega_a\\) to rzeczywiste współczynniki dla liniowej i kwadratowej części.\nThe QUBO objective function is NP-hard in nature.\nWprowadzmy zamianę zmiennych: \\[\nz_a = 2q_a-1\n\\] gdzie \\(z \\in {-1,1}\\)\n\\[\nF(z) = \\sum_a h_a z_a + \\sum_{a &lt; b} J_{a b} z_a z_b\n\\]\nOne popular method of encoding an optimization problem to be solved using QAOA, is to first formulate the problem as an Ising Objective function. The Ising model is a popular statistical mechanics model, associated primarily with ferromagnetism. Because it has been shown to be NP-Complete in nature, the objective function associated with it can be used to represent hard problems.\n\nMax-Cut\nMax-Cut is an NP-complete problem, with applications in clustering, network science, and statistical physics.\nGiven a graph \\(G(V,E)\\), we seek partition of \\(V\\) into two subsets with maximum cut.\nIn short, we have to color every node either blue or red and we score a point whenever an edge connects two nodes with different colors. We then would like to find the solution with the highest score.\n\nAgain, the problem in this specific graph coloring problem is that there are \\(2^N\\) possible solutions for \\(N\\) nodes (an exponential explosion in possibilities), making it impossible to enumerate all possible candidates for relevant system sizes.\nThe solution of Max-Cut, even if approximate, has practical application in machine scheduling, image recognition or for the layout of electronic circuits.\nWe can encode the Maximum Cut problem as a minimization problem of an Ising Hamiltonian, where the (classical) cost function reads: \\[ H_C = \\sum_{a &lt; b} J_{a b} z_a z_b \\]\nIsing matrix \\(J\\) encoding the weights of the edges.\nIn short, the cost Hamiltonian assigns a number to every bitstring \\(z=(z_1,z_2,\\dots,z_n)\\) , and we would like to find the lowest number possible. This will be the optimal assignment and solution to our problem.\nIt is important to note here that we still don’t know if quantum computing can help solve NP-Complete problems efficiently. Our hope for quantum algorithms, at the very least, is to be able to compete with classical heuristics when it comes to certain classes of hard problems.\nThe quantum Ising Hamiltonian, which naturally maps the Ising objective to qubits:\n\\[\\hat{C} = \\sum_{a &lt; b} J_{a b} \\hat{\\sigma}_a^z \\hat{\\sigma}_b^z \\] which can be written as a matrix of size \\((2^N, 2^N)\\) with diagonal elements only corresponding to all possible classical values for the cost function \\(\\hat{C}\\).\nBecause qubits are 2-dim vectors \\(\\sigma_a^z\\) correspond to 2x2 matrix with two eigenvalue \\(\\{1,-1\\}\\) and two eigenvectors \\[|0&gt; = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\\] \\[|1&gt; = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\\]\nSo\n\\[ \\sigma^z = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}\\]\nand\n\\[ \\sigma^z_a = \\left( \\otimes_{i=1}^{a-1} I \\right) \\otimes \\left( \\sigma^z \\right) \\otimes \\left(\\otimes_{i=a+1}^{n} I \\right)\\]\nThe other type of Hamiltonian in the QAOA process is a summation of individual Pauli X operators for each qubit involved in the process, which intuitively represents \\[\\hat{B}=\\sum_a \\sigma^x_a\\] transverse field in the Ising model \\[ \\sigma^x = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}\\]\n\\[ \\sigma^x_a = \\left( \\otimes_{i=1}^{a-1} I \\right) \\otimes \\left( \\sigma^x \\right) \\otimes \\left(\\otimes_{i=a+1}^{n} I \\right)\\]\nThe ground state of this Hamiltonian corresponds to the optimal solution of the classical combinatorial problem.\nFinding this ground state is generically hard.\n\n\nRealizacja kodu w pythonie\nFunctional programming breaks down an application into a set of functions. Ideally, functions only take inputs and produce outputs and have no internal state that affects the output produced for a given input.\nIn that sense, the QAOA algorithm is a function that solves a problem by optimizeing a set of params. In other words, we aim to find the best values for these params.\nTo decide which params are best, we assess them based on the result we obtain from computeing a (quantum) circuit that uses these params to encode the problem (problem_circuit) and its solution (ansatz_circuit).\nThis is what Qiskit’s description refers to as a variational algorithm.\nIt uses a classical optimization algorithm that makes queries to a quantum computer.\n\ndef qaoa(problem, optimize, assess, compute,\n  to_circuit, problem_circuit, ansatz_circuit):\n\n    return optimize(\n        lambda params: assess(problem, compute(to_circuit(problem, params,\n              problem_circuit, ansatz_circuit)))\n    )\n\n\nfrom qiskit import Aer, execute\n\ndef compute(circuit):\n    return execute(circuit, \n                   Aer.get_backend('qasm_simulator'), \n                   shots=1000).result().get_counts()\n\n\nfrom qiskit import QuantumCircuit\n\ndef to_circuit(problem, params, problem_circuit, ansatz_circuit):\n    \n    cnt_qubits = problem.size\n    \n    qc_qaoa = QuantumCircuit(cnt_qubits)\n\n    # initial_state\n    qc_qaoa.h(range(cnt_qubits))\n    \n    # append problem circuit\n    qc_qaoa.append(problem_circuit(problem, params[0]), range(cnt_qubits))\n    \n    # append ansatz circuit\n    qc_qaoa.append(ansatz_circuit(problem, params[1]), range(cnt_qubits))\n    qc_qaoa.measure_all()\n    \n    return qc_qaoa"
  },
  {
    "objectID": "lectures/wyklad4.html",
    "href": "lectures/wyklad4.html",
    "title": "Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych",
    "section": "",
    "text": "Zmianę stanu kwantowego w czasie opisuje Ewolucja kwantowa.\nRozważmy stan układu w chwili \\(t=0\\).\n\\[\\ket{\\psi_{t=0}}\\] W chwili \\(t=1\\) otrzymujemy stan \\(\\ket{\\psi_{t=1}}\\) t. że: \\[\\ket{\\psi_{t=1}} = \\textbf{U} \\, \\ket{\\psi_{t=0}} \\] gdzie \\(\\textbf{U}\\) jest macierzą unitarną.\nPowyższe równanie opisuje zachowanie wszystkich układów kwantowych.\nRozważmy stany bazowe \\(\\ket{0}\\), \\(\\ket{1}\\), które będziemy chcieli zamienic w ich superpozycję. \\[\n\\textbf{U}\\ket{0} = a\\ket{0} + b\\ket{1} = \\begin{bmatrix} a \\\\ b \\end{bmatrix}\n\\] \\[\n\\textbf{U}\\ket{1} = c\\ket{0} + d\\ket{1} = \\begin{bmatrix} c \\\\ d \\end{bmatrix}\n\\]\nKorzystając z tych równań możemy napisac: \\[\n\\textbf{U} = \\left( \\begin{bmatrix} a \\\\ b \\end{bmatrix} \\begin{bmatrix} c \\\\ d \\end{bmatrix}\\right) = \\begin{bmatrix} a \\, \\, b \\\\ c \\,\\, d \\end{bmatrix}\n\\]\nW informatyce macierze unitarne będą realizowały logiczne bramki kwantowe.\n\nDlaczego bramki kwantowe muszą by unitarne?\n\nNorma stanu kwantowego wynosi zawsze 1. Jest to prawdopodobieństwo całkowite sumy stanów bazowych. Prawdopodobieństwo to powinno by zachowane. Co oznacza, że chcemy znaleźc taką transformację, która nie zmienia długości (kwadratu) wektora. Taka transformacja realizowana jest przez obroty.\nWarto zwrócic uwagę na jeszcze jeden fakt. Macierz odwrotna do \\(\\textbf{U}\\) (oznaczana jako \\(\\textbf{U}^{-1}\\)) zawsze istnieje i jest ona równa sprzężeniu Hermitowskiemu macierzu \\(\\textbf{U}=\\textbf{U}^{\\dagger}\\). Dlatego ewolucja stanów kwantowych zawsze jest odwracalna. A to oznacza, że i bramki muszą by operacjami odwracalnymi. \\[\\ket{\\psi_{t=0}} = \\textbf{U}^{\\dagger} \\ket{\\psi_{t=1}} \\]",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#ewolucja-kwantowa",
    "href": "lectures/wyklad4.html#ewolucja-kwantowa",
    "title": "Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych",
    "section": "",
    "text": "Zmianę stanu kwantowego w czasie opisuje Ewolucja kwantowa.\nRozważmy stan układu w chwili \\(t=0\\).\n\\[\\ket{\\psi_{t=0}}\\] W chwili \\(t=1\\) otrzymujemy stan \\(\\ket{\\psi_{t=1}}\\) t. że: \\[\\ket{\\psi_{t=1}} = \\textbf{U} \\, \\ket{\\psi_{t=0}} \\] gdzie \\(\\textbf{U}\\) jest macierzą unitarną.\nPowyższe równanie opisuje zachowanie wszystkich układów kwantowych.\nRozważmy stany bazowe \\(\\ket{0}\\), \\(\\ket{1}\\), które będziemy chcieli zamienic w ich superpozycję. \\[\n\\textbf{U}\\ket{0} = a\\ket{0} + b\\ket{1} = \\begin{bmatrix} a \\\\ b \\end{bmatrix}\n\\] \\[\n\\textbf{U}\\ket{1} = c\\ket{0} + d\\ket{1} = \\begin{bmatrix} c \\\\ d \\end{bmatrix}\n\\]\nKorzystając z tych równań możemy napisac: \\[\n\\textbf{U} = \\left( \\begin{bmatrix} a \\\\ b \\end{bmatrix} \\begin{bmatrix} c \\\\ d \\end{bmatrix}\\right) = \\begin{bmatrix} a \\, \\, b \\\\ c \\,\\, d \\end{bmatrix}\n\\]\nW informatyce macierze unitarne będą realizowały logiczne bramki kwantowe.\n\nDlaczego bramki kwantowe muszą by unitarne?\n\nNorma stanu kwantowego wynosi zawsze 1. Jest to prawdopodobieństwo całkowite sumy stanów bazowych. Prawdopodobieństwo to powinno by zachowane. Co oznacza, że chcemy znaleźc taką transformację, która nie zmienia długości (kwadratu) wektora. Taka transformacja realizowana jest przez obroty.\nWarto zwrócic uwagę na jeszcze jeden fakt. Macierz odwrotna do \\(\\textbf{U}\\) (oznaczana jako \\(\\textbf{U}^{-1}\\)) zawsze istnieje i jest ona równa sprzężeniu Hermitowskiemu macierzu \\(\\textbf{U}=\\textbf{U}^{\\dagger}\\). Dlatego ewolucja stanów kwantowych zawsze jest odwracalna. A to oznacza, że i bramki muszą by operacjami odwracalnymi. \\[\\ket{\\psi_{t=0}} = \\textbf{U}^{\\dagger} \\ket{\\psi_{t=1}} \\]",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#bramki-jednokubitowe",
    "href": "lectures/wyklad4.html#bramki-jednokubitowe",
    "title": "Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych",
    "section": "Bramki jednokubitowe",
    "text": "Bramki jednokubitowe\nSpośród wszystkich bramek kwantowych istnieje kilka, które mają swoje ustalone nazwy. Są one często wykorzystywane w obliczeniach kwatnowych. Rozważmy stan \\[\n\\ket{\\psi} = \\alpha \\ket{0} + \\beta \\ket{1}\n\\]\n\nBramka identycznościowa\n\\[\n\\textbf{I} = \\begin{bmatrix} 1 \\,\\, 0 \\\\ 0 \\,\\, 1 \\end{bmatrix}\n\\]\nZobaczmy jak operator ten działa na stany bazowe: \\[ \\textbf{I} \\ket{0} = \\begin{bmatrix} 1 \\,\\, 0 \\\\ 0 \\,\\, 1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\]\n\\[ \\textbf{I} \\ket{1} = \\begin{bmatrix} 1 \\,\\, 0 \\\\ 0 \\,\\, 1 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\]\nDziałając na stan \\(\\ket{\\psi}\\) otrzymujemy: \\[\n\\textbf{I} \\ket{\\psi} = \\begin{bmatrix} 1 \\,\\, 0 \\\\ 0 \\,\\, 1 \\end{bmatrix} \\ket{\\psi} =  \\textbf{I} \\left( \\alpha \\ket{0} + \\beta \\ket{1} \\right) = \\alpha \\ket{0} + \\beta \\ket{1}\n\\]\n\n\nBramka negacji X (NOT)\n\\[\n\\textbf{X} = \\begin{bmatrix} 0 \\,\\, 1 \\\\ 1 \\,\\, 0 \\end{bmatrix}\n\\]\n\\[\n\\textbf{X} \\ket{0} = \\begin{bmatrix} 0 \\,\\, 1 \\\\ 1\\,\\, 0 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\ket{1}\n\\]\n\\[\n\\textbf{X} \\ket{1} = \\begin{bmatrix} 0 \\,\\, 1 \\\\ 1 \\,\\, 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\ket{0}\n\\]\nDziałając na stan \\(\\ket{\\psi}\\) otrzymujemy: \\[\n\\textbf{X} \\ket{\\psi} = \\begin{bmatrix} 0 \\,\\, 1 \\\\ 1 \\,\\, 0 \\end{bmatrix} \\ket{\\psi} =  \\textbf{X} \\left( \\alpha \\ket{0} + \\beta \\ket{1} \\right) = \\alpha \\ket{1} + \\beta \\ket{0}\n\\]\n\n\nBramka negacji fazy Y\n\\[\n\\textbf{Y} = \\begin{bmatrix} 0 \\,\\, -i \\\\ i \\,\\,\\,\\,\\,\\,\\, 0 \\end{bmatrix}\n\\]\n\\[\n\\textbf{Y} \\ket{0} = \\begin{bmatrix} 0 \\,\\, -i \\\\ i \\,\\,\\,\\,\\,\\,\\, 0 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = i \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = i \\ket{1}\n\\]\n\\[\n\\textbf{Y} \\ket{1} = \\begin{bmatrix} 0 \\, -i \\\\ i \\,\\,\\,\\,\\,\\, 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = -i \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = -i \\ket{0}\n\\]\nDziałając na stan \\(\\ket{\\psi}\\) otrzymujemy: \\[\n\\textbf{Y} \\ket{\\psi} = \\begin{bmatrix} 0 \\,\\, -i \\\\ i \\,\\,\\,\\,\\,\\, 0 \\end{bmatrix} \\ket{\\psi} =  \\textbf{Y} \\left( \\alpha \\ket{0} + \\beta \\ket{1} \\right) = \\alpha i \\ket{1} - \\beta i \\ket{0}\n\\]\n\n\nBramka negacji fazy i bitu Z\n\\[\n\\textbf{Z} = \\begin{bmatrix} 1 \\,\\,\\,\\,\\,\\,\\,\\,\\, 0 \\\\ 0\\,\\, -1 \\end{bmatrix}\n\\]\n\\[ \\textbf{Z} \\ket{0} = \\begin{bmatrix} 1\\,\\,\\,\\,\\,\\,\\, 0 \\\\ 0 \\, -1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = 1 \\ket{0} \\]\n\\[ \\textbf{Z} \\ket{1} = \\begin{bmatrix} 1 \\,\\,\\,\\,\\,\\,\\, 0 \\\\ 0 \\, -1 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = -1 \\ket{1}\\]\nDziałając na stan \\(\\ket{\\psi}\\) otrzymujemy: \\[\n\\textbf{Z} \\ket{\\psi} = \\begin{bmatrix} 0 \\,\\,\\,\\,\\,\\,\\, 1 \\\\ 0 \\, -1 \\end{bmatrix} \\ket{\\psi} =  \\textbf{Z} \\left( \\alpha \\ket{0} + \\beta \\ket{1} \\right) = \\alpha \\ket{0} - \\beta \\ket{1}\n\\]\n\n\nBramka Hadamarda H\n\\[\n\\textbf{H}= \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1\\,\\,\\,\\,\\,\\,\\, 1 \\\\ 1 \\, -1 \\end{bmatrix}\n\\]\n\\[\n\\textbf{H} \\ket{0} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1\\,\\,\\,\\,\\,\\,\\, 1 \\\\ 1 \\, -1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\frac{1}{\\sqrt{2}} \\left( \\ket{0} + \\ket{1} \\right) = \\ket{+}\n\\]\n\\[\n\\textbf{H} \\ket{1} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1\\,\\,\\,\\,\\,\\,\\, 1 \\\\ 1 \\, -1 \\end{bmatrix}  \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\frac{1}{\\sqrt{2}} \\left( \\ket{0} - \\ket{1} \\right) = \\ket{-}\n\\]\n\n\n\nLosowy bit\nStwórzmy pierwszy kwantowy program, który wykona zadanie niemożliwe do zrealizowania na komputerze klasycznym. Jak można zauważyc zdefiniowaliśmy bramkę Hadamarda. Brami tej nie było w klasycznych bramkach realizujących operacje na bitach.\nNa przestrzeni dziejów informatyki bardzo dużo czasu i wysiłku poświęcono opracowaniu systemu generowania liczb pseudolosowych (ang. PRNG - Pseudo Random Number Generator), który znalazł szerokie zastosowanie. Generowane liczby traktujemy jako pseudolosowe - tzn. jeśli znasz zawartośc pamięci komputera i algorytm PRNG możesz (przynajmniej teoretycznie) przewidzie jaka jest następna wartosc wygenerowanej liczby.\nZgodnie z zasadami fizyki zachwanie kubitu będącego w superpozycji w czasie dokonania pomiaru jest idealne i nieprzewidywalne. Dzięki temu już pojedynczy kubit pozwala wygenerowa najlepszy na świecie generator liczb losowych.\ninstrukcja\n\nPrzygotuj kubit w stanie początkowym \\(\\ket{0}\\).\nZastosuj bramkę Hadamarda tworząc z kubitu stan superpozycji stanów bazowych.\nWykonaj pomiar\n\nWłaśnie otrzymałeś QRNG - Quantum Random Number Generator. Nie jest to tani sposób na losow rzut monetą. Jednak trzeba miec swiadomośc, że tutaj nie ma wewnętrznego mechanizmu, który generuje losowośc - wynika ona tylko i wyłącznie z praw mechaniki kwantowej.\n\nCzy potrafisz wygenerowac losowy bajt?\n\n\n\nGra w obracanie monety\nWykorzystując powyżej zdefiniowane bramki możemy zrealizowa następującą grę:\n\nW grze bierze udział dwóch graczy. Gracze dysponują monetą, której nie widzą w trakcie gry (np. jest zamknięta w pudełku). Natomiast wiedzą, że początkowo moneta ułożona jest orłem do góry (w stanie \\(\\ket{0}\\)) Gra polega na wykonaniu trzech ruchów na przemian. Każdy ruch polega na odwróceniu monety bądź pozostawieniu jej w takim stanie w jakim była. Gracze nie wiedzą jaki ruch wykonuje przeciwnik. Po ostatnim ruchu pudełko zostaje otwarte i gracze sprawdzają w jakiej pozycji jest moneta. Pierwszy gracz wygrywa jeśli moneta jest w pozycji orła, a drugi jeśli przeciwnie.\n\nSzansa wygranej wynosi dla każdego \\(50\\%\\) i jak można sprawdzic nie istnieje strategia wygrywająca.\nPytanie zasadnicze - a co jeśli zamienimy monetę na kubit?\nMożliwe operacje pozostawienia kubitu w takim samym stanie - bramka I, zmiany stanu na przeciwny bramka X. Czyli pierwszy gracz ustala pierwszą bramkę, drugi drugą i ponownie pierwszy trzecią. Otwarcie pudełka to pomiar stanu kubitu.\n\nPrzeanalizuj wynik dla sekwencji I X I\n\nA co jeśli pierwszy gracz wie, że działa na kubicie?\n\nCzy może sprawic on, że wygra zawsze? (skoro wie, że działa na kubicie może użyc innych bramek)",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#bramki-dwukubitowe",
    "href": "lectures/wyklad4.html#bramki-dwukubitowe",
    "title": "Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych",
    "section": "Bramki dwukubitowe",
    "text": "Bramki dwukubitowe\nAnalogicznie do bramek jednokubitowych reprezentowanych przez macierze unitarne \\(2\\times 2\\) możemy skonstruowac dowolną wielo-kubitową bramkę. Dla n kubitów mamy \\(2^n \\times 2^n\\) unitarną macierz reprezentującą taką bramkę. Ponieważ bramki wielo kubiotwe działają na raz na kilka kubitów mogą służyc one do otrzymywania stanów splątanych. Mamy również możliwośc stworzyc bramkę warunkową (kontrolowaną), która zmienia bit docelowy jeśli kontrolny bit jest w stanie \\(\\ket{1}\\).\nW ogólności taka bramka może zostac zapisana jako: \\[\n\\textbf{CU}= \\ket{0}\\bra{0} \\otimes \\textbf{I} + \\ket{1}\\bra{1} \\otimes \\textbf{\\textbf{U}}\n\\]\nDowolna bramka działajaca na 1 kubit może byc przedstawiona jako mecierz \\[\n\\textbf{U} = \\begin{bmatrix} u_{00} \\, u_{01} \\\\ u_{10}\\, u_{11} \\end{bmatrix}\n\\]\ndlatego:\n\\[\n\\textbf{CU}=  \\begin{bmatrix} 1 \\,\\, \\,\\,\\, 0 \\,\\,\\,\\,\\, 0 \\,\\,\\,\\,\\, 0 \\\\\n0\\,\\, \\,\\,\\, 1 \\,\\,\\,\\,\\, 0 \\,\\,\\,\\,\\, 0 \\\\\n0\\,\\,\\,\\, 0\\,\\,\\,  u_{00} \\,\\, u_{01} \\\\ 0\\,\\,\\,\\, 0\\,\\,\\, u_{10}\\, \\, u_{11} \\end{bmatrix}\n\\]\nSzczegółowe działanie bramki można zapisac jako:\n\\[\\begin{align*}\n\\textbf{CU} \\ket{0} \\otimes \\ket{0} &=&  \\ket{0} \\otimes \\ket{0} \\\\\n\\textbf{CU} \\ket{0} \\otimes \\ket{1} &=& \\ket{0}\\otimes \\ket{1} \\\\\n\\textbf{CU} \\ket{1}\\otimes \\ket{0} &=& \\ket{1}\\otimes \\textbf{U} \\ket{0} \\\\\n\\textbf{CU} \\ket{1}\\otimes \\ket{1} &=& \\ket{1}\\otimes \\textbf{U} \\ket{1} \\\\\n\\end{align*}\\]\nDla kwantowej bramki NOT \\(\\textbf{U}= X\\) \\[\n\\text{CNOT} = \\begin{bmatrix} 1 \\,\\, \\,\\,\\, 0 \\,\\,\\,\\,\\, 0 \\,\\,\\,\\,\\, 0 \\\\\n0\\,\\, \\,\\,\\, 1 \\,\\,\\,\\,\\, 0 \\,\\,\\,\\,\\, 0 \\\\\n0\\,\\,\\,\\,\\, 0\\,\\,\\,\\,\\,  0 \\,\\,\\,\\,\\, 1 \\\\ 0\\,\\,\\,\\,\\, 0\\,\\,\\,\\,\\, 1\\,\\,\\,\\,\\, 0 \\end{bmatrix}\n\\] Bramka ta do drugiego kubitu (targetu) stosuje bramkę X jeśli pierwszy kubit jest w pozycji \\(\\ket{1}\\). W przeciwnym wypadku nie zmienia się nic.\n\\[\\begin{align*}\n\\textbf{CNOT} \\ket{0} \\otimes \\ket{0} &=&  \\ket{0} \\otimes \\ket{0} \\\\\n\\textbf{CNOT} \\ket{0} \\otimes \\ket{1} &=& \\ket{0}\\otimes \\ket{1} \\\\\n\\textbf{CNOT} \\ket{1}\\otimes \\ket{0} &=& \\ket{1}\\otimes \\ket{1} \\\\\n\\textbf{CNOT} \\ket{1}\\otimes \\ket{1} &=& \\ket{1}\\otimes \\ket{0} \\\\\n\\end{align*}\\]\n\nRozpoczynajac od stanu \\(\\ket{0} \\otimes \\ket{0}\\) zadziałaj na pierwszy kubit bramka Hadamarda a na tak otrzymany stan zadziałaj CNOT. Jaki stan uzyskujemy?",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html",
    "href": "lectures/wyklad3.html",
    "title": "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów",
    "section": "",
    "text": "\\[\n\\newcommand{\\bra}[1]{\\left \\langle #1 \\right \\rvert}\n\\newcommand{\\ket}[1]{\\left \\rvert #1 \\right \\rangle}\n\\newcommand{\\braket}[2]{\\left \\langle #1 \\middle \\rvert #2 \\right \\rangle}\n\\]\nMechanika Kwantowa opiera się na algebrze liniowej. W ogólności teoria ta posługuje się pojęciem nieskończenie wymiarowej przestrzeni liniowej. Na szczęście do opisu kubitów (2-dim) i układów kwantowych (\\(2^{n}\\)-dim) wystarczy nam pojęcie skończenie wymiarowej przestrzeni wektorowej. Bardzo upraszcza nam to naukę o kwantowym uczeniu maszynowym, gdyż wiele problemów matematycznych (dla fizyków) tutaj nie występuje. Upraszcza to również ilość potrzebnych matematycznych pojęć.\nBędziemy posługiwali się notacją Diraca, jednego z twórców mechaniki kwantowej. W książce Ch. Bernhardta “Obliczenia kwantowe dla każdego” autor rezygnuje z liczb zespolonych, na rzecz liczb rzeczywistych. O ile podejście takie sprawdza się na poziomie opisu o tyle dla pełnego zrozumienia posługiwanie się liczbami zespolonymi jest niezbędne.",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#liczby-rzeczywiste-i-zespolone---przypomnienie",
    "href": "lectures/wyklad3.html#liczby-rzeczywiste-i-zespolone---przypomnienie",
    "title": "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów",
    "section": "Liczby rzeczywiste i zespolone - przypomnienie",
    "text": "Liczby rzeczywiste i zespolone - przypomnienie\nLiczby to matematyczne, abstrakcyjne pojęcia wywodzące się z teorii mnogości (zbiorów). Przykładowo, liczbę 42 można zapisa w postaci dziesiętnej lub binarnej \\(42=101010_2\\). Możemy znaleźć 42 przedmioty i je przeliczyć, ale w naszym przypadku skupimy się na abstrakcyjnym pojęciu liczby, niezależnie od jej reprezentacji. Liczba 42 jest liczbą naturalną. Zbiór liczb naturalnych oznaczamy jako \\(\\mathbb{N}\\). Identyczne cechy abstrakcji mają liczby całkowite \\(\\mathbb{Z}\\), liczby wymierne \\(\\mathbb{Q}\\), liczby rzeczywiste \\(\\mathbb{R}\\) oraz liczby zespolone \\(\\mathbb{C}\\). Nie możemy zobaczyć ani dotknąć liczb, ale możemy wykonywać na nich operacje matematyczne. Liczb Warto zaznaczyc,że liczby zespolone nie są bardziej abstrakcyjne niż liczby rzeczywiste, czy naturalne.\nLiczba zespolona (we współrzędnych Kartezjańskich) składa się z (dwóch liczb rzeczywistych) części rzeczywistej i urojonej: \\[z=x + i y\\] gdzie \\(i^2=-1\\).\nNatomiast częśc rzeczywista \\(R(z)=x\\) i częśc urojona \\(I(z)=y\\).\nNa przykład: \\[1+i\\sqrt{3}\\] \\(R(z)=1\\) i \\(I(z)=\\sqrt{3}\\).\nInaczej mówiąc, liczba zespolona jest sumą liczby rzeczywistej i urojonej.\nLiczy zespolone, można traktowac jako punkty na płaszczyźnie o współrzędnych \\(x\\) i \\(y\\).\n\nKażdą liczbę zespoloną możemy zapisać w postaci polarnej (współrzędne biegunowe) \\[ z=r\\, e^{i \\phi} , \\] gdzie \\(r=|z|\\) to moduł liczby zespolonej, a \\(\\phi\\) to jej argument czyli wyrażony w radianach kąt między osią rzeczywistą a półprostą poprowadzoną od środka ukł. wsp. i przechodzącą przez punkt \\(z\\). \\[ z = r\\, e^{i \\, \\phi} = r\\, (\\cos{\\phi} + i\\, \\sin{\\phi})\\] gdzie: \\[r = |z| = \\sqrt{x^2 + y^2}\\] \\[\\phi = \\arctan{\\frac{y}{x}}. \\] Natomiast: \\[x = r \\cos{\\phi}\\] \\[y = r \\sin{\\phi}\\]\nDla naszego przykładu: \\[1+i\\sqrt{3} = 2 e^{i \\frac{\\pi}{3}} . \\]\n\nUdowodnij samodzielnie, że powyższe równanie jest prawdziwe.\n\nLiczby zespolone można dodawa, mnożyc i dzieli zgodnie z zwykłymi regułami arytmetyki. Dodawanie liczb zespolonych jest łatwe dla liczb w postaci kartezjańskiej. Natomiast mnożenie liczb zespolonych upraszcza się dla postaci biegunowej (następuje zamiana mnożenia na dodawanie fazy).\nLiczba sprzężona do liczby zespolonej powstaje poprzez zmianę znaku części urojonej\n\\(z=x + i\\, y\\,\\,\\,\\,\\) to \\(\\,\\,\\,z^*=x - i y = r*e^{-i \\phi}\\).\nNorma liczby zespolonej \\(z=x + i y\\,\\,\\,\\,\\) to \\(\\,\\,\\,|z|=\\sqrt{x^2 + y^2}=r\\).\nKwadrat normy liczby zespolonej \\(z=x + i y\\,\\,\\,\\,\\) to \\(\\,\\,\\, |z|^2=x^2 + y^2=r^2\\). Warto zauważyc, że każdy kwadrat modułu daje w wyniku nieujemną liczbę rzeczywistą.\nMożna go również zapisać jako \\[|z|^2=z z^* = z^* z\\]\nCzynniki fazowe to szczególna klasa liczb zespolonych \\(z\\) dla której \\(r=1\\).\nOtrzymujemy wtedy: \\[\nz=e^{i \\phi}=\\cos{\\phi} + i\\, \\sin{\\phi}\\] \\[\nz z^* = 1\n\\]\n\nUdowodnij w kartezjańskim i polarnym układzie oniesienia.\n\n\nile wynosi \\(z_1 z_2\\)\n\n\nile wynosi \\(\\frac{z_1}{z_2}\\)",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#wektory-i-przestrzenie-wektorowe",
    "href": "lectures/wyklad3.html#wektory-i-przestrzenie-wektorowe",
    "title": "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów",
    "section": "Wektory i przestrzenie wektorowe",
    "text": "Wektory i przestrzenie wektorowe\nNiech dany będzie zbiór \\(\\mathbb{V}\\) oraz zbiór \\(\\mathbb{K}\\). Elementy zbioru \\(\\mathbb{V}\\) można ze sobą dodawać i mnożyć przez elementy zbioru \\(\\mathbb{K}\\). Wraz z dodatkowymi opracjami (zdefiniowanymi poniżej) zbiór ten będziemy nazwywali przestrzenią wektorową. Jej elementy to wektory ket \\(\\ket{u}\\) (lub kety).\nJeśli współczynniki liczbowe wektorów będą rzeczywiste to będziemy mówić o przestrzeni wektorowej rzeczywistej. Natomiast jeśli liczby te będą zespolone to będziemy mówić o przestrzeni wektorowej zespolonej.\nMyśląc o wektorach często wyobrażamy je sobie jako strzałki w przestrzeni. Przez strzałki rozumiemy tutaj obiekty znajdujące się w zwykłej przestrzeni i posiadające wielkoś oraz kierunek. Wektory takie mają trzy składowe - trzy (rzeczywiste) współrzędne przestrzenne.\nNa tych zajęciach lepiej zapomniec o tej koncepcji. Wszystkie wektory będą reprezentowane jako abstrakcyjne elementy przestrzeni wektorowej. Warto jednak pamiętać, że wszystkie własności (algebraiczne) wektorów są również spełnione dla strzałek.\n\nAksjomaty przestrzeni stanów\nNiech \\(\\ket{v}\\) , \\(\\ket{u}\\), \\(\\ket{z}\\) będą dowolnymi wektorami, natomiast \\(\\alpha\\) i \\(\\beta\\) dowolnymi liczbami.\n\nSuma dwóch wektorów ket jest wektorem ket \\[\\ket{v} + \\ket{u} = \\ket{z}\\]\nDodawanie wektorów jest przemienne: \\[\\ket{v} + \\ket{u} = \\ket{u} + \\ket{v}\\]\nDodawanie wektorów jest łączne: \\[\\ket{v} + (\\ket{u} + \\ket{z}) = (\\ket{v} + \\ket{u}) + \\ket{z}\\]\nIstnieje szczególny (i jedyny) wektor \\(\\ket{v}\\) odwrotny do wektora \\(\\ket{u}\\): \\[\\ket{v} + \\ket{u} = 0\\]\nIstnieje szczególny (i jedyny) wektor \\(0\\) zerowy. Dla każdego wektora \\(\\ket{v}\\) zachodzi: \\[\\ket{v} + 0 = 0 + \\ket{v} = \\ket{v}\\]\n1*wektor = wektor: \\[1 \\ket{v} = \\ket{v}\\]\nŁączność mnożenia przez skalar: \\[\\alpha (\\beta \\ket{v}) = (\\alpha \\beta) \\ket{v}\\]\nRozdzielność mnożenia przez skalar względem dodawania wektorów: \\[\\alpha (\\ket{v} + \\ket{u}) = \\alpha \\ket{v} + \\alpha \\ket{u}\\]\nRozdzielność dodawania skalarów względem mnożenia przez wektor: \\[(\\alpha + \\beta) \\ket{v} = \\alpha \\ket{v} + \\beta \\ket{v}\\]\n\n\n\nWektory kolumnowe\nZapiszmy pionową jednokolumnową tablicę liczb: \\[ \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix} \\]\nMnożenie przez liczbę: \\[ \\alpha \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix} = \\begin{bmatrix} \\alpha x_1 \\\\ \\alpha x_2 \\\\ .\\\\ \\alpha x_n \\end{bmatrix} \\]\nDodawanie kolumn: \\[ \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix} + \\begin{bmatrix} y_1 \\\\ y_2 \\\\ .\\\\ y_n \\end{bmatrix} = \\begin{bmatrix} x_1+y_1 \\\\ x_2+y_2 \\\\ .\\\\ x_n+y_n \\end{bmatrix}\\]\nPozwala to otrzymać konkretną reprezentację wektorów, które będziemy oznaczać w notacji Diraca przez “ket” \\(\\ket{.}\\).\n\n\nWektory wierszowe\n\\[ \\begin{bmatrix} x_1 \\,\\, x_2 \\,\\, \\dots \\,\\, x_n \\end{bmatrix}\\]\nAnalogicznie do poprzedniego przykładu łatwo określić jak dodawać je ze sobą i mnożyć przez liczbę. W notacji Diraca będziemy takie wektory oznaczali przez “bra” \\(\\bra{.}\\).\n\n\nTranspozycja i sprzężenie Hermitowskie.\nTranspozycja \\(T\\) Zamienia wektory wierszowe na kolumnowe i odwrotnie.\n\\[ \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix}^{T} = \\begin{bmatrix} x_1 \\,\\, x_2 \\,\\, \\dots \\,\\, x_n \\end{bmatrix}\\]\noraz \\[ \\begin{bmatrix} x_1 \\,\\, x_2 \\,\\, \\dots \\,\\, x_n \\end{bmatrix}^{T} = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix}\\]\nNatomiast sprzężenie hermitowskie \\(\\dagger = T \\ast\\) dodatkowo do transpozycji dodaje sprzężenie zespolone.\n\\[\\ket{u}^{\\dagger} = \\bra{u}\\] \\[\\bra{u}^{\\dagger} = \\ket{u}\\]\nCzyli: \\[ (\\ket{u} + \\ket{v})^{\\dagger} = \\bra{u} + \\bra{v} \\] oraz \\[ \\alpha \\ket{u} \\to \\bra{u} \\alpha^*\\]\n\\[ \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix}^{\\dagger} = \\begin{bmatrix} x_1^* \\,\\, x_2^* \\,\\, \\dots \\,\\, x_n^* \\end{bmatrix}\\]\noraz \\[ \\begin{bmatrix} x_1 \\,\\, x_2 \\,\\, \\dots \\,\\, x_n \\end{bmatrix}^{\\dagger} = \\begin{bmatrix} x_1^* \\\\ x_2^* \\\\ .\\\\ x_n^* \\end{bmatrix}\\]\n\n\nIloczyn skalarny\nIloczynem skalarnym dwóch wektorów \\(\\ket{u}\\) i \\(\\ket{v}\\) nazywany funkcję, która zwraca liczbę.\n\n\\(\\braket{u}{v} = \\braket{v}{u}^{\\ast}\\)\n\\((\\alpha \\bra{u})\\ket{v} = \\alpha \\braket{u}{v}\\)\n\\((\\bra{u} + \\bra{v}) \\ket{z} = \\braket{u}{z} +\\braket{v}{z}\\)\n\\(\\braket{u}{u} &gt; 0\\)\n\\(\\braket{u}{u} = 0, gdy \\ket{u}=\\ket{0}\\)\n\nDla dwóch wektorów \\(\\ket{u}\\) i \\(\\ket{v}\\) otrzymujemy: \\[ \\ket{u} = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix}, \\ket{v} = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ .\\\\ y_n \\end{bmatrix} \\]\n\\[ \\braket{u}{v} = x_1^{*}y_1 +x_2^{*}y_2 + \\dots + x_n^{*}y_n\\]\n\nZadanie - Udowodnij, że \\(\\braket{u}{u}\\) jest liczbą rzeczywistą.\n\nwektor znormalizowany \\(\\braket{u}{u}=1\\)\nwektory ortogonalne \\(\\braket{u}{v}=0\\)\n\n\nKombinacja liniowa wektorów\nDla dwóch wektorów \\(\\ket{u}\\) i \\(\\ket{v}\\) oraz dwóch liczb \\(\\alpha\\), \\(\\beta\\) możemy stworzyć nowy wektor: \\[\\ket{z} = \\alpha \\ket{u} + \\beta \\ket{v}\\] Wektor ten nazywamy kombinacją liniową wektorów \\(\\ket{u}\\) i \\(\\ket{v}\\) o współczynnikach \\(\\alpha\\) i \\(\\beta\\).\n\n\nBaza\nKażda przestrzeń wektorowa ma bazę.\nDowolny wektor można zapisa jako kombinację liniową wektorów bazowych.\nInteresowac będzie nas baza (obliczeniowa) dla której:\n\\[ \\braket{e_i}{e_i}=1 \\,\\, \\braket{e_i}{e_j}=0 \\,\\, \\text{dla i} \\neq j \\] gdzie \\(i,\\,j = 1,2,\\dots, n\\).\nDowolny wektor \\(\\ket{u}\\) możemy zapisa jako: \\[ \\ket{u} = \\braket{e_1}{u}\\ket{e_1} + \\braket{e_2}{u}\\ket{e_2} + ... + \\braket{e_n}{u}\\ket{e_n}  \\]\nWarto zauważyc: \\[\\braket{e_1}{u}= x_1\\] \\[\\ket{u} = \\sum_{i=1}^{n} \\ket{i}\\bra{i} \\ket{u}\\]",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#formalizm-matematyczny-obliczeń-kwantowych",
    "href": "lectures/wyklad3.html#formalizm-matematyczny-obliczeń-kwantowych",
    "title": "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów",
    "section": "Formalizm matematyczny obliczeń kwantowych",
    "text": "Formalizm matematyczny obliczeń kwantowych\nTa wiedza wystarczy do wyjaśnienia notacji Diraca.\nIloczyn skalarny \\(\\braket{\\psi}{\\phi}\\) wektorów \\(\\ket{\\psi}\\) i \\(\\ket{\\phi}\\) czytamy jako braket u v.\n\nStan\nW fizyce klasycznej znajomość stanu układu oznacza, iż wiemy wszystko co jest potrzebne\nStanem w mechanice kwantowej nazywamy wektor:\n\\[\\ket{\\psi} = x_0 \\ket{0} + x_1 \\ket{1} + \\dots x_{n-1} \\ket{n-1}\\]\nChcemy aby współczynniki \\(x_i\\) były liczbami zespolonymi a cały wektor był unormowany do 1.\nLiczby \\(x_i\\) nazywamy amplitudami prawdopodobieństwa stanu kwantowego. Jeśli przynajmniej dwie liczby \\(x_i\\) są niezerowe, to układ znajduje się w superpozycji stanów.\n\n\nKubit\nElementarnym obiektem w informatyce kwantowej jest kubit, który realizowany jest jako dwu wymiarowy układ kwantowy. Stan kwantowy kubitu opisuje wektor w przestrzeni liniowej \\(\\mathbb{C}^2\\).\nW celu wykonywania obliczeń i opisu stanu kubitu wybierzemy tzw. bazę obliczeniową: \\[\\ket{0} = \\begin{bmatrix} 1 \\\\ 0  \\end{bmatrix} , \\ket{1} = \\begin{bmatrix} 0 \\\\ 1  \\end{bmatrix}\\]\nTo co wyróżnia kubit w porównaniu do klasycznego bitu dowolny stan \\(\\ket{\\psi}\\) może być superpozycją stanów bazowych: \\[\n\\ket{\\psi} = \\alpha \\ket{0} + \\beta \\ket{1} = \\alpha \\begin{bmatrix} 1 \\\\ 0\\end{bmatrix} + \\beta \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}\n\\] dla którego zachodzi warunek normalizacji: \\[\n\\braket{\\psi}{\\psi} = |\\alpha|^2 + |\\beta|^2 = 1\n\\] gdzie \\(\\alpha, \\beta \\in \\mathbb{C}\\).\n\nZADANIE - oblicz \\(\\braket{\\psi}{\\psi}\\).\n\nLiczby \\(\\alpha\\) i \\(\\beta\\) nazywamy amplitudami prawdopodobieństwa. Są one reprezentowane przez liczby zespolone. Potrzeba 4 liczb rzeczywistych aby je opisać. Ze względu na warunek normalizacji jedną liczbę można obliczyc co oznacza potrzebę użycia już tylko trzech liczb rzeczywiste.\nStan kubitu możemy zapisać w postaci: \\[\n\\ket{\\psi} = e^{i \\gamma}\\left( \\cos{\\frac{\\phi}{2}} \\ket{0} + e^{i \\theta} \\sin{\\frac{\\phi}{2}} \\ket{1} \\right)\n\\] gdzie \\(\\phi \\in [0, \\pi]\\), \\(\\theta \\in [0, 2\\pi]\\) i \\(\\gamma \\in [0, 2\\pi]\\) są liczbami rzeczywistymi.\nWspółczynnik \\(e^{i \\gamma}\\) nazywamy fazą globalną. Ze względu, iż analizować będziemy kwadraty amplitud prawdopodobieństwa to faza globalna nie ma znaczenia. Dlatego możemy napisać: \\[\n\\ket{\\psi} = \\cos{\\frac{\\phi}{2}} \\ket{0} + e^{i \\theta} \\sin{\\frac{\\phi}{2}} \\ket{1}\n= \\begin{bmatrix} \\cos{\\frac{\\phi}{2}} \\\\ e^{i \\theta} \\sin{\\frac{\\phi}{2}} \\end{bmatrix}\n\\]\nWarto zauważyć, że dwa dowolne stany kubitów \\(\\ket{\\psi}\\) i \\(\\ket{\\phi}\\) różnią się o czynnik fazowy \\(e^{i \\gamma}\\) to stany te dają identyczne wyniki.\nLiczby rzeczywiste \\(\\phi\\) i \\(\\theta\\) nazywamy kątami kubitu i możemy interpretować je jako współrzędne na sferze Blocha. Bardzo często będziemy wykorzystywać ją do wizualizacji stanów kubitów.\nStany w bazie obliczeniowej, którymi często będziemy operowac: \\[\\ket{+} = \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1})\\] \\[\\ket{-} = \\frac{1}{\\sqrt{2}}(\\ket{0} - \\ket{1})\\] \\[\\ket{i} =\\frac{1}{\\sqrt{2}}(\\ket{0} + i \\ket{1})\\] \\[\\ket{-i} =\\frac{1}{\\sqrt{2}}(\\ket{0} - i \\ket{1})\\]\nLub: \\[\\frac{1}{\\sqrt{2}}(\\ket{0} + e^{i\\pi/6} \\ket{1})\\] \\[\\frac{\\sqrt{3}}{2}(\\ket{0} + \\frac{1}{2} \\ket{1})\\]\n\nKubit może by dowolnym punktem na sferze Blocha.\n\n\n\nDwa kubity\nZłączenie układu dwóch kubitów realizowane jest przez iloczyn tensorowy (iloczyn Kroneckera).\nRozważmy dwa stany kubitów \\(\\ket{\\psi}\\), \\(\\ket{\\phi}\\)\n\\[\n\\ket{\\psi} = \\alpha \\ket{0} + \\beta \\ket{1} = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}\\, ,\\,\\,\n\\ket{\\phi} = \\gamma \\ket{0} + \\delta \\ket{1} = \\begin{bmatrix} \\gamma \\\\ \\delta \\end{bmatrix}\n\\]\nStan dwukubitowy: \\[\n\\ket{\\psi} \\otimes \\ket{\\phi} = \\begin{bmatrix} \\alpha \\gamma \\\\ \\alpha \\delta \\\\ \\beta \\gamma \\\\ \\beta \\delta \\end{bmatrix} = \\alpha \\gamma \\ket{0} \\otimes \\ket{0} + \\beta \\delta \\ket{1} \\otimes \\ket{0}  + \\alpha \\delta \\ket{0} \\otimes \\ket{1}  + \\beta \\delta \\ket{1} \\otimes \\ket{1}\n\\] co możemy zapisa jako: \\[\n\\ket{\\psi \\phi} = \\alpha \\gamma \\ket{00} + \\beta \\delta \\ket{10}  + \\alpha \\delta \\ket{01}  + \\beta \\delta \\ket{11}\n\\] gdzie: \\[\n\\ket{00} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\, \\,\n\\ket{01} = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\, \\,\n\\ket{10} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{bmatrix}, \\, \\,\n\\ket{11} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix}\n\\]\nPo przenumerowaniu stanów możemy napisac: \\[\n\\ket{\\Phi} = c_0 \\ket{0} + c_1 \\ket{1}  + c_2 \\ket{2}  + c_3 \\ket{3}\n\\] dla którego: \\[\n|c_0|^2 + |c_1|^2 + |c_2|^2 + |c_3|^2 = 1\n\\]\n\n\nStan separowalny i splątany\nJeżeli istnieją stany \\(\\ket{\\phi_1}\\) i \\(\\ket{\\phi_2}\\) takie, że \\[\\ket{\\psi} = \\ket{\\phi_1} \\otimes \\ket{\\phi_2}\\] to stan nazywamy separowalny.\nZobaczmy, czy istnieje przypadek w którym stan układu dwóch kubitów nie da się zaprezentowac jako iloczynu tensorowego podukładów. Aby to sprawdzic zobaczmy czy istnieją takie liczby \\(c_0, c_1, c_2, c_3\\) dla których nie da się znaleźc \\(\\alpha, \\beta,\\gamma, \\delta\\), które spełniają układ równań: \\[c_0 = \\alpha \\gamma , \\, c_1 = \\alpha \\delta , \\, c_2 = \\beta \\gamma , \\, c_3 = \\beta \\delta \\]\nRozważmy stan \\[\\ket{bell} = \\frac{1}{\\sqrt{2}}(\\ket{0}+\\ket{3}) = \\frac{1}{\\sqrt{2}}(\\ket{00}+\\ket{11})\\]\nZałóżmy, że możemy zapisa stan bell w postaci: \\[ \\alpha \\gamma \\ket{0} + \\beta \\delta \\ket{1}  + \\alpha \\delta \\ket{2}  + \\beta \\delta \\ket{3} \\]\nAby stan bell był separowalny musi by spełniony układ równań:\n\\[\\begin{eqnarray}\n\\alpha \\gamma = \\frac{1}{\\sqrt{2}} \\\\ \\alpha \\delta = 0 \\\\ \\beta \\gamma = 0 \\\\ \\beta \\delta =\\frac{1}{\\sqrt{2}}\n\\end{eqnarray}\\]\nZ warunku drugiego mamy dwie możliwości: albo \\(\\alpha=0\\) lub \\(\\delta=0\\). Jeżeli \\(\\alpha=0\\) to warunek pierwszy nie może byc spełniony. Jeżeli \\(\\delta=0\\) to warunek czwarty nie może byc spełniony. Otrzymujemy sprzecznośc.\nProwadzi to do wniosu, że stan bell'a nie jest stanem separowalnym i jest stanem splątanym. Stany te mają bardzo nieintuicyjne własności. Związany jest z nimi słynny paradox EPR oraz tak zwane nierówności Bella.\n\nSplątane stany Bell’a, wraz z zasadą superpozycji będą podstawowymi kwantowymi własnościami pozwalającymi zrealizowac przewagę obliczeń kwantowych nad obliczeniami klasycznymi.",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#pomiar-w-bazie-z",
    "href": "lectures/wyklad3.html#pomiar-w-bazie-z",
    "title": "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów",
    "section": "Pomiar w bazie Z",
    "text": "Pomiar w bazie Z\nW opisie kubitów wybraliśmy specyficzą bazę (obliczeniową) wektorów, która rozkłada każdy wektor na kombinację wektora \\(\\ket{0}\\) i \\(\\ket{1}\\).\nZasady przestrzeni wektorowej i mechaniki kwantowej dopuszczają tworzenie kombinacji liniowej (superpozycji) dla tych dwóch stanów. \\[\n\\ket{\\psi} = \\alpha \\ket{0} + \\beta \\ket{1}\n\\] Po pomiarze kubitu, czyli na końcu procesu obliczeniowego, ze względu na prawa fizyki otrzymujemy tylko i wyłącznie jeden ze stanów bazowych \\(\\ket{0}\\) lub \\(\\ket{1}\\). Każdy następny pomiar (tej samej obserwabli) będzie kończyc się w tym samym (otrzymanym) stanie.\n\nPomiar niszczy superpozycję kubitu i sprowadza go do jednego ze stanów bazowych.\n\nDla kubitu w superpozycji stanów bazowych jedyne co możemy określic to prawdopodobieństwo otrzymania stanu \\(\\ket{0}\\) i \\(\\ket{1}\\).\n\nPrawdopodobieństwo określone jest jako kwadrat (modułu) amplitudy Dla stanu \\(\\ket{0}\\) \\(P(0) = |\\alpha|^2\\) oraz dla stanu \\(\\ket{1}\\) \\(P(1)= |\\beta|^2\\).\n\nIstnieje możliwośc pomiaru kubitów w innych bazach. Jednak w większości przypadków ograniczymy się do pomiaru w bazie obliczeniowej.\n\nPrzykład\nRozważmy stan \\[\\ket{\\psi} = \\frac{\\sqrt{3}}{2}\\ket{0}+\\frac{1}{2}\\ket{1}\\]\nMożliwe wyniki pomiaru w bazie Z \\(\\{ \\ket{0},\\ket{1} \\}\\).\n\\[\n\\braket{0}{\\psi} = \\bra{0}\\left( \\frac{\\sqrt{3}}{2}\\ket{0} +\\frac{1}{2}\\ket{1}\\right) = \\frac{\\sqrt{3}}{2}\\braket{0}{0} + \\frac{1}{2}\\braket{0}{1} = \\frac{\\sqrt{3}}{2}\n\\] Biorąc kwadrat apmlitudy otrzymujemy kubit w stanie \\(\\ket{0}\\) z prawdopodobieństwem \\(0.75\\). \\[\n\\braket{1}{\\psi} = \\bra{1}\\left( \\frac{\\sqrt{3}}{2}\\ket{0} +\\frac{1}{2}\\ket{1}\\right) = \\frac{\\sqrt{3}}{2}\\braket{1}{0} + \\frac{1}{2}\\braket{1}{1} = \\frac{1}{2}\n\\] Biorąc kwadrat apmlitudy otrzymujemy stan \\(\\ket{1}\\) z prawdopodobieństwem \\(0.25\\).\n\\[\\ket{\\psi} = \\braket{0}{\\psi}\\ket{0} + \\braket{1}{\\psi}\\ket{1}\\]\nDowolna para liniowo niezależnych wektorów jednostkowych \\(\\ket{u}\\) i \\(\\ket{v}\\) pochodząca z dwuwymiarowej przestrzeni wektorowej może tworzyc bazę: \\[\n\\alpha \\ket{0} +\\beta \\ket{1} = \\alpha' \\ket{u} +\\beta' \\ket{v}\n\\] Przykładem może byc tzw Baza Hadamarda \\(\\ket{+}\\) i \\(\\ket{-}\\) zdefiniowana jako: \\[\n\\ket{+} = \\frac{1}{\\sqrt{2}}(\\ket{0}+\\ket{1}) = \\begin{bmatrix} \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\end{bmatrix}\n\\] \\[\n\\ket{-} = \\frac{1}{\\sqrt{2}}(\\ket{0}-\\ket{1}) = \\begin{bmatrix} \\frac{1}{\\sqrt{2}} \\\\ - \\frac{1}{\\sqrt{2}} \\end{bmatrix}\n\\]\n\nBardzo ważnym etapem jest wybór bazy w której dokonujemy pomiaru. np. dla wektora \\(\\ket{+}\\) pomiar w bazie standardowej pozwoli otrzymac wyniki stanu \\(\\ket{0}\\) i \\(\\ket{1}\\) z prawdopodobieństwami \\(\\frac{1}{2}\\). Natomiast jeśli pomiar dokonywany byłby w bazie Hadamarda to zawsze otrzymamy stan \\(\\ket{+}\\) z prawdopodobieństwem 1.",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#kilka-ciekawostek-matematycznych",
    "href": "lectures/wyklad3.html#kilka-ciekawostek-matematycznych",
    "title": "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów",
    "section": "Kilka ciekawostek matematycznych",
    "text": "Kilka ciekawostek matematycznych\nStan kubitów, czyli dwuwymiarowych układów kwantowych, opisujemy wektorem ket \\(\\ket{a}\\). Wektory te reprezentowane są jako listy zapisane w kolumnach. \\[ \\ket{a} = \\begin{bmatrix} a_0 \\\\ a_1 \\end{bmatrix} \\]\nOprócz wektorów ket wprowadziliśmy wektory bra powstające w wyniku operacji transpozycji i sprzęzenia zespolonego. Operacja ta jest bijekcją. \nPrzez bijekcję rozumiemy odwzorowanie bądź funkcję, która każdemu elementowi dziedziny przypisuje tylko jeden element przeciwdziedziny oraz dodatkowo cały zbiór dziedziny jest odwzorowany na przeciwdziedzinę. Zauważ, że druga własność jest potrzebna do zdefiniowania funkcji odwrotnej. Aby mówić o funkcji (odwrotnej), wszystkie elementy dziedziny (przeciwdziedziny) muszą zostać odwzorowane. Dzięki tej własności możemy zdefiniować całą przestrzeń dualną, w której podstawowymi składnikami są wektory dualne. Ponadto, wszystkie elementy przestrzeni wektorów bra mają swoje różne odpowiedniki w przestrzeni ketów i odwrotnie. To pozwala również stwierdzić, że tak naprawdę obie przestrzenie są izomorficzne, czyli takie same. Jedyną różnicą jest forma zapisu elementów. Operacja ta podobna jest do wpowadzenia wektorów dualnych na poziomie zakrzywionych rozmaitości rózniczkowalnych (ang. manifolds). W drugim przypadku definiujemy wektory kontrawariantne i kowariantne.\nWektory bra definiujemy jako listę wierszową. \\[ \\bra{b} = \\begin{bmatrix} a_0 \\,\\,\\,  a_1 \\end{bmatrix} \\]\nDo definicji przestrzeni wektorowej dodaliśmy definicję iloczynu skalarny. Zauważ, iz nie mówimy w tym przypadku o działaniu. Działania definiowały nam własności przestrzeni wektorowej. Wynikiem dodawania wektorów jak i mnożenia ich przez liczbę był zawsze jakiś wektor. A więc działania nie wyprowadzały nas poza przestrzeń wektorową. W przypadku iloczynu skalarnego wybieramy wektor oraz drugi wektor dualny. Po złozeniu jednego i drugiego otrzymujemy liczbę (skalar). \\[ \\braket{a}{b} \\]\nDo jego wprowadenia wymagane było wprowadzenie przestrzeni dualnej.\nKorzystając z wektorów bra i ket możemy zdefiniować jeszcze jedną operacje.\n\\[ \\ket{a} \\bra{b} \\] Tym razem to co otrzymujemy mozemy traktować jako operator.",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html",
    "href": "lectures/wyklad2.html",
    "title": "Klasyczne bramki logiczne - Algebra Boola",
    "section": "",
    "text": "\\[\n\\newcommand{\\bra}[1]{\\left \\langle #1 \\right \\rvert}\n\\newcommand{\\ket}[1]{\\left \\rvert #1 \\right \\rangle}\n\\newcommand{\\braket}[2]{\\left \\langle #1 \\middle \\rvert #2 \\right \\rangle}\n\\]\nObliczenia (przetwarzanie) wykonywane przez komputer możemy zdefiniować jako transformacje jednego stanu pamięci na inny. Z matematycznego punktu widzenia oznacza to, że obliczenia to funkcje, które przekształcają informacje.\nW przypadku klasycznych komputerów podstawową jednostką pamięci jest bit (ang. binary digit). Funkcje, które operują na bitach nazywamy bramkami logicznymi (ang. logic gates).",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Klasyczne bramki logiczne - Algebra Boola"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#bramki-logiczne",
    "href": "lectures/wyklad2.html#bramki-logiczne",
    "title": "Klasyczne bramki logiczne - Algebra Boola",
    "section": "Bramki logiczne",
    "text": "Bramki logiczne\nBramki logiczne to funkcje Boolowskie, które możemy składać w bardziej złożone układy (ang. circuits). Stworzone przez George’a Boole’a w 1854 roku, algebra boola jest matematyczną strukturą, która opisuje zachowanie się obiektów, które mogą przyjmować tylko jedną z dwóch wartości: prawda lub fałsz. Zdolne są one do wykonywania np. dodawania, mnożenia czy też innych bardziej skomplikowanych operacji.\nW latach trzydziestych XX wieku Claude Shannon zastosował algebrę boola do analizy i projektowania układów elektrycznych. Co oznacza, że zareprezentował on funkcje boolowskie za pomocą przełączników elektrycznych. Dlatego też komponenty elektroniczne odpowiadające funkcjom boolowskim nazywamy bramkami logicznymi.\n\nCiekawostka. Richard Feynman wykładał teorię obliczeń na Kalifornijskim Instytucie Technologii. Wykład ten prezentowany jest obecnie jako Feynmana wykłady o obliczeniach (ang. Feynman Lectures on Computation).\n\n\nZ pozoru obliczenia przedstawione w ten sposób wyglądają jako abstrakcjny matematyczny koncept. Jednak jego realizacja zawsze wymaga jakiegoś układu fizycznego realizującego wykonywanie funkcji. Nie ma znaczenia jak ten układ zostanie zrealizowany: kule bilardowe, przełączniki elektroniczne, tranzystory, czy cokolwiek innego.\n\nLogika obliczeń jest niezależna od realizacji bramek logicznych.\n\nZ punktu widzenia realizacji zawsze chodzi nam o kontrolowany sposób zmiany stanu układu.\nNa wykładzie postaramy się wskazać jak i kiedy logika klasycznych obliczeń może być uogólniona przez logikę obliczeń kwantowych. Jasne jest, że przypadek klasyczny powinien być szczególnym przypadkiem kwantowego.\nobwody klasyczne\nZobaczmy jakie bramki możemy określić dla jednego bitu.\n\nBramki logiczne dla jednego bitu\nIle bramek mamy gdy input = 1 bit, output = 1 bit? Ile funkcji możemy zdefiniować dla odwzorowania jednego bitu w jeden bit?\nWszystkie cztery operatory działające na jednym bicie możemy określić jako:\n\nIdentyczność (ang. identity) - \\(I(0)=0\\), \\(I(1)=1\\)\nNegacja (ang. negation, NOT, filps) - \\(NOT(0)=1\\), \\(NOT(1)=0\\)\nStałe zero \\(ZERO(0)=0\\), \\(ZERO(1)=0\\)\nStałe jeden \\(ONE(0)=1\\), \\(ONE(1)=1\\)\n\nPo zastosowaniu operatora \\(I\\) oraz \\(NOT\\), z otrzymanego wyniku możemy wyznaczyc wartości początkowe. Jednak po zastosowaniu dwóch pozostałych operacji \\(ZERO\\) i \\(ONE\\) nie jesteśmy w stanie określic jaki był stan początkowy, który wygenerował określony wynik.\nTe dwie własności pozwalają nam sklasyfikowac operatory jako:\n\nOdwracalne - możemy odtworzyc wartośc początkową z wartości końcowej\nNieodwracalne - NIE możemy odtworzyc wartości początkowej z wartości końcowej.\n\nJak pokażemy później, wszystkie operatory reprezentujące kwantowe bramki będą odwracalne.\n\n\nInne bramki i operacje logiczne\n\nZróbmy krótkie przedstawienie niektórych, klasycznych bramek logicznych.\nBramka logiczna jest implementacją funkcji boolowskiej. Operacją logiczną przeprowadzaną na jednym lub kilku binarnych wejściach produkującą jedną binarną wartość wyjściową. \\[f: \\{0,1\\}^{n} \\to \\{0,1\\} \\]\nKażdy element algebry boola (Boolean Statements) musi być określony jako prawda albo fałsz.\nBramki logiczne możemy wyrazić za pomocą tablicy prawdy (ang. truth table). Tablica ta posiada jedną kolumnę dla każdej zmiennej wejściowej oraz jedną kolumnę dla zmiennej wyjściowej. Kolumna wyjściowa przedstawia wszystkie możliwe wyniki przedstawianej logicznej operacji reprezentowanej przez tablicę. Każdy wiersz tablicy prawdy reprezentuje jedną możliwą kombinację (konfiguracje) danych wejściowych oraz wyniku.\nPodstawowe bramki, które znasz to:\n\nAND - koniunkcja\nOR - alternatywa\nNOT - negacja\nNAND - not and\nXOR - alternatywa wykluczająca (Exclusive OR) - dodawanie modulo 2\n\n\nZadanie: zapisz tablicę prawdy dla każdej bramki.\n\n\nNOT gate\n\n\n\nA\nnot A\n\n\n\n\n0\n\n\n\n1\n\n\n\n\n\n\nAND gate\n\n\n\nA\nB\nC\n\n\n\n\n0\n0\n\n\n\n1\n0\n\n\n\n0\n1\n\n\n\n1\n1\n\n\n\n\n\n\nOR gate\n\n\n\nA\nB\nC\n\n\n\n\n0\n0\n\n\n\n1\n0\n\n\n\n0\n1\n\n\n\n1\n1\n\n\n\n\n\n\nNAND\n\n\n\nA\nB\nC\n\n\n\n\n0\n0\n\n\n\n1\n0\n\n\n\n0\n1\n\n\n\n1\n1\n\n\n\n\n\n\nXOR\n\n\n\nA\nB\nC\n\n\n\n\n0\n0\n\n\n\n1\n0\n\n\n\n0\n1\n\n\n\n1\n1\n\n\n\n\nPowyższe bramki pozwalają łączyć poszczególne elementy algebry boola ze sobą.\n\nZadanie: Porównaj AND oraz OR z potocznym znaczeniem tych słów.\n\n\nZadanie: Dlaczego Algebra boola nazywana jest algebrą zbiorów?\n\n\nZadanie: Czy składanie podzbiorów zbioru również generuje algebrę boola ?\n\n\nZadanie: ile bramek logicznych możemy stworzyć dla jednego bitu, dwóch bitów, trzech bitów?\n\n\n\n\nUniweralne bramki logiczne - NAND\nTak jak widzieliśmy dla 1-bitu informacji mieliśmy 4 bramki logiczne. Dla 2-bitów mieliśmy 16 bramek logicznych. Dla 3-bitów mamy już 256 możliwości.\nW przypadku 2-bitów nie wypisaliśmy wszystkich bramek, dlaczego?\nCzy musimy realizować wszystkie?\n\nNa szczęście odpowiedź jest negatywna.\n\nIstnieją tzw. zbiory bramek uniwersalnych dzięki którym możemy zrealizować dowolną funkcję boolowską.\n\nNOT, AND, OR\nNAND, AND\nNAND\nNOT, OR\nNOR",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Klasyczne bramki logiczne - Algebra Boola"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#szyfrowanie-z-wykorzystaniem-bramki-xor",
    "href": "lectures/wyklad2.html#szyfrowanie-z-wykorzystaniem-bramki-xor",
    "title": "Klasyczne bramki logiczne - Algebra Boola",
    "section": "Szyfrowanie z wykorzystaniem bramki XOR",
    "text": "Szyfrowanie z wykorzystaniem bramki XOR\nWeźmy dwie sekwencje bitów:\nsekwencja A - przedstawiająca naszą zakodowaną wiadomośc: \\[1 0 1 1 0 1 1 1 0 0 0\\]\nlosowa sekwencja B: \\[0 1 1 0 1 1 0 1 1 0 1\\]\ni obliczmy XOR między dwoma sekwencjami (dla poszczególnych kolumn) \\(A\\) XOR \\(B\\).\nZgodnie z tablicą prawdy dla XOR otrzymujemy: \\[1 1 0 1 1 0 1 0 1 0 1\\]\nNa otrzymanym wyniku jeszcze raz zastosuj bramkę XOR.\nCo możesz zauważyć?\n\nOblicz A XOR B XOR B.\n\nZamień wiadomość, którą chcesz zaszyfrować na binarną postać (czyli jako sekwencję zer i jedynek).\nWeź losową sekwencję bitów (klucz szyfrujący), którą zna tylko nadawca i odbiorca.\n\\(1001011010...\\) - wiadomość\n\\(0110101010...\\) - klucz szyfrujący, czyli losowa sekwencja bitów\nZaszyfruj wiadomość wykonując operację XOR na każdym bicie wiadomości i klucza szyfrującego. Tak otrzymaną wiadomość (zaszyfrowaną) wyślij do odbiorcy.\n\ndecyrpting message\nOdbiorca otrzymuje zaszyfrowaną wiadomość (posiada klucz szyfrujący).\nMessage XOR SecretSequence = EncryptedMessage\nMessage XOR SecretSequence XOR SecretSequence = Message\nNie powinniśmy używać SecretSequence więcej niż raz. Jeśli użyjemy jej więcej niż raz, to łatwo jest złamać szyfrowanie.\n\nDlaczego nie powinno się używać szyfru więcej niż jeden raz? Podpowiedź: Zakodowana wiadomość przestaje być losowa.",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Klasyczne bramki logiczne - Algebra Boola"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html",
    "href": "lectures/wyklad1.html",
    "title": "Komputery klasyczne i kwantowe",
    "section": "",
    "text": "Nature isn’t classical, dammit, and if you want to make a simulation of Nature, you’d better make it quantum mechanical, and by golly it’s a wonderful problem because it doesn’t look so easy. Richard Feynman",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Komputery klasyczne i kwantowe"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#zanim-zaczniemy",
    "href": "lectures/wyklad1.html#zanim-zaczniemy",
    "title": "Komputery klasyczne i kwantowe",
    "section": "Zanim zaczniemy",
    "text": "Zanim zaczniemy\n\nCo oznacza termin kwantowe uczenie maszynowe?\n\n\nCo wiesz o obliczeniach kwantowych?\n\n\nJakie masz oczekiwania i dlaczego interesujesz się QML?",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Komputery klasyczne i kwantowe"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#podstawowe-pojęcia",
    "href": "lectures/wyklad1.html#podstawowe-pojęcia",
    "title": "Komputery klasyczne i kwantowe",
    "section": "Podstawowe pojęcia",
    "text": "Podstawowe pojęcia\nUczenie maszynowe (w tym także uczenie głębokie) to dziedzina, która łączy naukę i technikę, pozwalając komputerom uczyć się na podstawie danych. Dzięki temu mogą one rozwiązywać problemy, których tradycyjne programowanie nie byłoby w stanie efektywnie rozwiązać – ze względu na złożoność, brak wzorców lub dynamicznie zmieniające się dane. Zamiast ręcznie programować konkretne rozwiązania, algorytmy uczą się na podstawie dostępnych danych, aby samodzielnie znaleźć wzorce i optymalne odpowiedzi. Więcej na ten temat znajdziesz w książce\nObliczenia kwantowe to interdyscyplinarna dziedzina wykorzystująca świat nauki kwantowej (fizyki, chemii) i technologii. Rozwija takie dziedziny jak: projektowanie algorytmów, teoria obliczeń złozonych, optymalizacja, architektura systemów komputerowych, czy tworzenie sprzętu komputerowego.\n\nWarto zauważyć, że klasyczne komputery (bazujące na tranzystorach) również działają zgodnie z prawami mechaniki kwantowej, jednak wykonywane przez nie operacje opierają się na klasycznej logice.\n\nOba podejścia – klasyczne i kwantowe – odgrywają kluczową rolę w przetwarzaniu danych zarówno dziś, jak i w niedalekiej przyszłości. Zatem nasuwa się naturalne pytanie: jak można te dwa światy ze sobą połączyć?\nXanadu link - what is quantum computing\nKwantowe uczenie maszynowe (ang. Quantum Machine Learning) to zastosowanie metod uczenia maszynowego, które mogą być realizowane na komputerach kwantowych. Wykorzystuje ono zjawiska mechaniki kwantowej, takie jak superpozycja i splątanie, aby potencjalnie przyspieszyć procesy uczenia i rozwiązywania problemów, które dla klasycznych komputerów mogą być zbyt złożone.\nXanadu link - What is QML\n\nyou start with classical mechanics and electrodynamics, solving lots of differential equations at every step. Then you learn about the “black-body paradox” and various strange experimental results, and the great crisis these things posed for physics. Next you learn a complicated patchwork of ideas that physicists invented between 1900 and 1926 to try to make the crisis go away. Then, if you’re lucky, after years of study you finally get around to the central conceptual point: that nature is described not by probabilities (which are always non-negative), but by numbers called amplitudes that can be positive, negative, or even complex. Scott Aaronson, Quantum Computing Since Democritus\n\nXanadu link - QML blog",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Komputery klasyczne i kwantowe"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#sztuczna-inteligencja",
    "href": "lectures/wyklad1.html#sztuczna-inteligencja",
    "title": "Komputery klasyczne i kwantowe",
    "section": "Sztuczna inteligencja",
    "text": "Sztuczna inteligencja\n\nHistoria sztucznej inteligencji (AI) sięga 1950 roku, kiedy Alan Turing zaproponował swój słynny test Turinga. Od tamtej pory rozwój technologii AI przyspieszył, obejmując zarówno dane ustrukturyzowane, jak i nieustrukturyzowane. Przykłady zastosowań AI obejmują:\n\nrozpoznawanie i generowanie mowy,\n,,rozumienie’’ obrazów i filmów,\nrozgrywanie gier (np. szachy, Go),\nsystemy rekomendacji (np. w e-commerce),\ndiagnostykę (np. w medycynie),\nplanowanie i optymalizację procesów,\npodejmowanie decyzji,\nchatboty i wirtualnych asystentów.\n\nWszystkie te zadania są realizowane dzięki zastosowaniu uczenia maszynowego (Machine Learning) oraz głębokich sieci neuronowych (Deep Learning).\nDlaczego sztuczna inteligencja jest tak chętnie wykorzystywana?\n\nWykładniczy wzrost ilości danych treningowych, dostępnych m.in. dzięki mediom społecznościowym, Internetowi, aplikacjom mobilnym i urządzeniom IoT.\nWzrost mocy obliczeniowej oraz spadek kosztów sprzętu komputerowego (np. co-procesorów GPU, TPU).\nDostępność oprogramowania typu Open Source, ułatwiającego rozwój AI.\nPrzewaga konkurencyjna, jaką zyskują firmy wykorzystujące AI w porównaniu do tych, które tego nie robią.\n\n\n\nUwaga! Zakładam, że masz podstawową znajomość pojęć związanych z uczeniem maszynowym i głębokim, ale w razie potrzeby, będziemy przypominać kluczowe zagadnienia.\n\n\nKategorie uczenia maszynowego\nUczenie maszynowe (ang. Machine Learning) można podzielić na kilka głównych kategorii:\n\nUczenie nadzorowane (ang. supervised learning) – mając oznaczone dane \\((x_i, y_i)\\) , uczymy model, który znajdzie funkcję \\(f(x_i) = y_i\\) , aby poprawnie przewidywać wartości dla nowych, nieznanych danych. Przykłady obejmują decyzje o przyznaniu kredytu lub klasyfikację obrazów, takich jak rozpoznanie, czy na obrazie znajduje się kot, czy pies.\nUczenie nienadzorowane (ang. unsupervised learning) – mając nieoznaczone dane (x_i) , szukamy ukrytych struktur w danych, takich jak grupowanie (klasteryzacja) czy redukcja wymiarów. Celem jest odkrywanie zależności lub wzorców, które nie są jawnie widoczne.\nUczenie przez wzmacnianie (ang. reinforcement learning) – agent uczy się podejmować decyzje w środowisku na podstawie nagród i kar, optymalizując swoje działania w celu maksymalizacji długoterminowych korzyści. Przykłady obejmują gry komputerowe, sterowanie robotami czy optymalizację procesów biznesowych.\nUczenie transferowe (ang. transfer learning) – technika, która polega na wykorzystaniu wiedzy nabytej w jednym zadaniu do rozwiązania innych, podobnych zadań. Przykładem jest model językowy nauczony rozumienia języka naturalnego, który może być wykorzystany do innych zadań, takich jak tłumaczenie maszynowe, analiza sentymentu czy rozpoznawanie tekstu pisanego.\nUczenie pół-nadzorowane (ang. semi-supervised learning) – podejście, które łączy dane oznaczone (z etykietami) i nieoznaczone (bez etykiet) w celu trenowania modelu. Jest to przydatne, gdy dostępnych jest dużo danych nieoznaczonych, ale tylko niewielka część z nich ma przypisane etykiety.",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Komputery klasyczne i kwantowe"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#klasyczny-model-obliczeń",
    "href": "lectures/wyklad1.html#klasyczny-model-obliczeń",
    "title": "Komputery klasyczne i kwantowe",
    "section": "Klasyczny model obliczeń",
    "text": "Klasyczny model obliczeń\nKomputer to fizyczne urządzenie, które przetwarza informacje za pomocą obwodów elektronicznych (ang. electronic circuits). Jego działanie opiera się na klasycznej logice binarnej, w której informacje są reprezentowane przez bity przyjmujące wartości \\(0\\) lub \\(1\\). Komputery klasyczne wykonują obliczenia, przetwarzając te bity za pomocą zestawu logicznych operacji, takich jak \\(AND\\), \\(OR\\), \\(NOT\\), oraz innych.\nKomputery klasyczne opierają swoje działanie na:\n\nProcesorach (CPU – Central Processing Unit), które wykonują instrukcje programu.\nPamięci (RAM – Random Access Memory), która tymczasowo przechowuje dane potrzebne do obliczeń.\nMagazynach danych, takich jak dyski twarde (HDD) lub półprzewodnikowe dyski (SSD), które służą do trwałego przechowywania danych.\nObwodach logicznych, zbudowanych na podstawie tranzystorów, które tworzą podstawowe elementy przetwarzania danych.\n\nKomputery klasyczne są niezwykle wydajne w rozwiązywaniu szerokiego spektrum problemów, zwłaszcza tych, które dają się łatwo zredukować do logicznych operacji lub operacji arytmetycznych. Jednakże, w miarę wzrostu złożoności problemów, ich wydajność może być ograniczona przez dostępne zasoby obliczeniowe i czas.\n\nAlgorytmy (programy komputerowe – ang. software) to sekwencje logicznych i matematycznych kroków, które definiują sposób rozwiązywania problemów lub wykonywania obliczeń przy użyciu komputera. Algorytmy są abstrakcyjnymi przepisami, które programy komputerowe implementują, aby przetwarzać dane i osiągać zamierzone cele. Wykorzystują one zasoby obliczeniowe komputera, takie jak procesor, pamięć i dysk, do wykonywania zadań w określonej kolejności i z określoną efektywnością.\nPrawo Moore’a\n\nPrawo Moore’a to obserwacja, że liczba tranzystorów na mikroczipie podwaja się mniej więcej co dwa lata, podczas gdy jego koszt zmniejsza się o połowę w tym samym okresie. Wzrost mocy mikroprocesorów jest wykładniczy.\n\nZwiększenie szybkości działania oraz pojemności klasycznych komputerów co dwa lata pozwala na szybsze i bardziej złożone obliczenia przy niższych kosztach. Jednak w ostatnich latach obserwujemy, że prawo Moore’a zbliża się do swoich fizycznych ograniczeń. Miniaturyzacja tranzystorów staje się coraz trudniejsza, co sugeruje, że dalszy wzrost mocy obliczeniowej komputerów tradycyjnych może być trudniejszy do osiągnięcia w dotychczasowy sposób.\n\n\nFizyczne (klasyczne) ograniczenia dla procesorów\n\nRozmiary tranzystora: Rozmiary tranzystorów zbliżają się do skali atomowej. W latach 90-tych tranzystory miały rozmiar około 500 nm, obecnie mają około 14 nm, a najnowsze technologie osiągają nawet 7 nm. Dalsze zmniejszanie rozmiarów napotyka na ograniczenia związane z fizyką materiałów.\nPrędkość światła: Jest to maksymalna prędkość przesyłu informacji w tradycyjnych układach komputerowych. Ogranicza to szybkość, z jaką dane mogą być przesyłane pomiędzy komponentami procesora i pamięci.\nWysoki koszt wytwarzania: Proces produkcji nowoczesnych układów scalonych jest bardzo kosztowny. To skłania do rozwoju układów wieloprocesorowych i rozwiązań z większą liczbą rdzeni w celu zwiększenia wydajności bez konieczności ciągłego zmniejszania tranzystorów.\nEfekty kwantowe: Gdy tranzystory stają się coraz mniejsze, pojawiają się efekty kwantowe, które mogą wpływać na ich działanie. Te efekty stają się istotne, gdy rozmiar tranzystora zbliża się do skali atomowej. Komputery kwantowe są próbą obejścia tych ograniczeń.\nWysoki pobór mocy: Zmniejszanie rozmiarów tranzystorów często prowadzi do zwiększenia gęstości obliczeniowej, co z kolei zwiększa pobór mocy i generuje więcej ciepła.\nGenerowanie ciepła: Zaawansowane komputery wykonujące intensywne obliczenia generują znaczne ilości ciepła. Problemy z chłodzeniem mogą wpływać na wydajność i niezawodność systemu, co wymaga innowacji w zakresie rozwiązań chłodzących.\nWykorzystanie rzadkich materiałów: Produkcja mikroprocesorów i układów scalonych wymaga rzadkich materiałów i zasobów, co może stanowić wyzwanie dla zrównoważonego rozwoju technologii komputerowych.\n\nDla większości praktycznych zastosowań opis makroskopowy oraz klasyczne teorie fizyczne są wystarczające do opisu właściwości prądu w obwodach elektrycznych. Jednak gdy celem jest realizacja obliczeń wykorzystujących mikroskopowe właściwości obiektów, klasyczny opis przestaje być adekwatny.\nW takich przypadkach konieczne jest zwrócenie się ku mechanice kwantowej, która jest najdokładniejszym i najbardziej powszechnie stosowanym modelem opisującym mikroświat. Komputer, który realizuje obliczenia zgodnie z zasadami mechaniki kwantowej, nazywamy komputerem kwantowym.\nDzięki zdolności do wykorzystania zjawisk kwantowych, takich jak superpozycja i splątanie, komputery kwantowe mogą rozwiązywać problemy, które są trudne lub wręcz niemożliwe do rozwiązania za pomocą klasycznych komputerów. Komputery kwantowe oferują obiecującą technologię, która otwiera nowe możliwości w dziedzinie obliczeń oraz nauki.",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Komputery klasyczne i kwantowe"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#obliczenia-kwantowe",
    "href": "lectures/wyklad1.html#obliczenia-kwantowe",
    "title": "Komputery klasyczne i kwantowe",
    "section": "Obliczenia kwantowe",
    "text": "Obliczenia kwantowe\n\nFilm wprowadzający: link\n\nNowy paradygmat obliczeń kwantowych wykorzystuje unikalne cechy interferencji, superpozycji i splątania do realizacji obliczeń. Obecnie realizowany jest w trzech głównych modelach:\n\nQuantum Circuits (Obwody Kwantowe) - oparty na modelu bramkowym, pozwala realizować algorytmy typu QAOA, VQA oraz metody hybrydowe.\nAdiabatyczne Obliczenia Kwantowe (D-Wave) - polegające na minimalizacji energii, wykorzystując optymalizację QUBO i analogię do modelu Isinga.\nTopologiczne Komputery Kwantowe - oparte na topologicznych kubitach.\n\n\nNie za krótkie wprowadzenie do fizyki kwantowej\nTermin Mechanika Kwantowa (MK) jest często używany zamiennie z teorią kwantową, choć istnieją również inne teorie kwantowe, takie jak Kwantowa Teoria Pola (ang. quantum field theory), które wykraczają poza zakres standardowej mechaniki kwantowej.\nMechanika Kwantowa przewiduje wyniki eksperymentów przeprowadzanych na układach kwantowych, tj. mikroskopowych obiektach fizycznych, dla których fizyka klasyczna nie jest wystarczająca do opisania ich zachowania. Przykładem może być atom wodoru. MK opisuje zachowanie takich obiektów jak fotony, elektrony oraz kwantowe bity (qubity).\nWarto zaznaczyć, że Mechanika Kwantowa jest fundamentem, na którym opiera się wiele innych teorii i dziedzin fizyki, w tym teorie kwantowe stosowane w obliczeniach kwantowych.\n\nNa naszym wykładzie nie będziemy koncentrować się na fizycznych właściwościach kubitów, lecz ograniczymy się do znajomości ich pewnych, abstrakcyjnych stanów, w jakich mogą się znajdować. Stany te będą numerowane liczbami naturalnymi.\n\nFizyka klasyczna jest zazwyczaj traktowana jako graniczny przypadek mechaniki kwantowej. Mimo to, w praktyce fizycy często oddzielają te dwie dziedziny i stosują odpowiednią teorię do odpowiednich problemów. Na przykład, w konstrukcji mostów wykorzystuje się fizykę klasyczną, a nie mechanikę kwantową.\nWarto również zaznaczyć, że wyniki mechaniki kwantowej mają charakter probabilistyczny, co może prowadzić do błędnego przekonania, że mechanika kwantowa jest teorią statystyczną. W rzeczywistości mechanikę kwantową można raczej uznać za uogólnienie klasycznej definicji prawdopodobieństwa.\n\n\nHistoria fizyki kwantowej\nPoczątki Mechaniki Kwantowej sięgają prac Maxa Plancka (1900) i Alberta Einsteina (1905), którzy wprowadzili pojęcie kwantu - najmniejszej jednostki energii. Rozwój tej dziedziny związany jest z badaniami wielu wybitnych naukowców, takich jak Niels Bohr, Erwin Schrödinger, Louis de Broglie, Werner Heisenberg, Paul Dirac, Richard Feynman i wielu innych.\nSzczegółowe informacje na temat historii obliczeń kwantowych można znaleźć w artykule o obliczeniach kwantowych.\n\nInformatyków zazwyczaj nie interesuje, jak dokładnie fizyczne właściwości układów są wykorzystywane do przechowywania informacji w komputerze klasycznym. Podobnie, nie muszą oni zgłębiać fizycznego mechanizmu, dzięki któremu informacja kwantowa jest realizowana w komputerze kwantowym. Tak jak prowadząc samochód, nie zastanawiasz się nad działaniem każdej jego części, tak samo pisząc kod, nie musisz interesować się, jak został on zaimplementowany w bibliotece. Informatycy często koncentrują się na efektywnym wykorzystaniu technologii komputerowych, a nie na szczegółach ich fizycznej realizacji.\n\n\n\nRealizacja komputerów kwantowych\nprocesory kwantowe\n\n\n\nHistoria obliczeń kwantowych\n\n1936: Alan Turing opublikował pracę On Computable Numbers, która stanowiła istotny krok w kierunku teoretycznych podstaw obliczeń (Hilbert Problems) - universal computing machine\n1976: Roman S. Ingarden opublikował artykuł Quantum Information Theory, wprowadzając pojęcie teorii informacji kwantowej, co miało kluczowe znaczenie dla rozwoju komputerów kwantowych.\n1980: Paul Benioff przedstawił teoretyczną koncepcję komputerów kwantowych jako fizycznych systemów, otwierając drzwi do praktycznych implementacji.\n1981: Richard Feynman zwrócił uwagę na to, że klasyczne komputery nie są w stanie efektywnie symulować procesów kwantowych.\n1985: David Deutsch opracował pierwszy opis kwantowej maszyny Turinga oraz algorytmy przeznaczone do uruchamiania na komputerach kwantowych, w tym bramki kwantowe.\n1994: Peter Shor opracował algorytm faktoryzacji liczb w czasie wielomianowym, co miało znaczenie dla kryptografii i bezpieczeństwa informacji.\n1996: Lov Grover stworzył algorytm Grovera, który okazał się wyjątkowo efektywny w przeszukiwaniu stanów kwantowych.\n2000: Zbudowano pierwszy komputer kwantowy (5 qubitów) oparty na nuklearnym rezonansie magnetycznym, co stanowiło ważny krok w rozwoju fizycznych platform komputerów kwantowych.\n2001: Demonstracja algorytmu Shora potwierdziła praktyczność i znaczenie algorytmów kwantowych.\n2007: Firma D-Wave sprzedała pierwszy komercyjny komputer kwantowy, co miało wpływ na rozwój technologii komputerów kwantowych w sektorze prywatnym.\n2019: 23 października, Google ogłosił uzyskanie tzw. quantum supremacy na 53 kubitach.\n2020: Zespół Jian-Wei Pana z University of Science and Technology of China dokonał przełomu, realizując 76 fotonowych kubitów na komputerze Jiuzhang.\n2022: Firma Xanadu dokonała znaczących postępów w dziedzinie technologii komputerów kwantowych.\n2023: Pojawienie się pierwszego logicznego qubitu? (wymaga dalszych szczegółów lub aktualizacji)\n2024: Google - Pierwsze zadowalające wyniki z kwantowej korekcji błędów\n\nOd około 1990 roku fizycy i informatycy pracują nad fizyczną realizacją komputerów kwantowych. Jednym z popularnych modeli obliczeń na komputerach kwantowych jest model oparty na kwantowych obwodach (ang. quantum circuits), który wykorzystuje qubity zamiast klasycznych bitów.\nPodobnie jak w przypadku obwodów klasycznych, w modelu kwantowym definiuje się bramki kwantowe (ang. quantum gates), które umożliwiają wykonywanie operacji na qubitach.\nFizyczna konstrukcja komputera kwantowego, a właściwie qubitu, jest zadaniem nietrywialnym, ponieważ wymaga manipulacji bardzo małym układem, który jest zazwyczaj wyjątkowo wrażliwy na wszelkie oddziaływania z otoczeniem. Efektem tych oddziaływań jest pomiar układu, który prowadzi do przejścia do jego stanu własnego (co oznacza zniszczenie przygotowanego stanu, np. superpozycji). Efekt ten nazywa się dekoherencją.\n\n\n\nDlaczego chcemy używać komputerów kwantowych?\nZasadnicze pytanie brzmi: na ile komputery kwantowe mogą faktycznie poprawić jakość modeli uczenia maszynowego i czy umożliwią realizację zadań, które są poza zasięgiem klasycznych komputerów.\n\nCo o tym sądzisz?\n\nMoja i książkowa odpowiedź: To zależy:\n\njaki problem chcemy rozwiązać?\njakie dane są dostępne i jakiej są natury?\njaki typ analizy chcemy przeprowadzić?\njaki typ komputera kwantowego wykorzystujemy (np. NISQ czy pełnoskalowy komputer kwantowy)?\nco rozumiemy przez “lepiej”? Precyzja, czas obliczeń, koszt, skalowalność, zużycie energii, a może coś innego?\n\n\nKwantowa Złożoność (Quantum Complexity)\nProblemy, które klasycznie są trudne do rozwiązania, takie jak optymalizacja, mogą być realizowane szybciej przez komputery kwantowe. Przykładem jest faktoryzacja liczb.\nPodstawowym faktem przewagi komputerów kwantowych nad klasycznymi jest tzw. parallelizm. Dzięki temu, że kubity mogą znajdować się w superpozycji stanów, komputer kwantowy może przeprowadzać obliczenia jednocześnie na wszystkich stanach. Co dokładnie to oznacza, poznamy w dalszej części wykładu.\nRozważmy sytuację, w której chcemy poznać działanie funkcji \\(f(x)\\) dla pewnego argumentu \\(x\\) . Aby znaleźć wynik dla dwóch liczb (np. \\(x = 0\\) i \\(x = 1\\)), klasyczny komputer musi wykonać dwie operacje. Komputer kwantowy może uzyskać ten wynik, przeprowadzając obliczenia jednocześnie dla obu wartości. Do wykonania takiej operacji wystarczy jeden kubit.\nJeśli chcemy obliczyć naszą funkcję dla kolejnych liczb \\(x = 2\\) (które binarnie reprezentowane jest jako 10 ) oraz liczby \\(x = 3\\) (binarnie 11 ), musimy dodać kolejny kubit. Dwa kubity mogą posłużyć do realizacji czterech równoległych operacji. Jeśli rozważymy 3 kubity, możemy podwoić liczbę operacji (3 kubity mają 8 stanów bazowych). Dodanie kubitu do komputera kwantowego pozwala podwoić liczbę równoległych obliczeń. W przypadku klasycznego komputera, aby uzyskać taki efekt, trzeba by podwoić liczbę bitów. Generalnie, n -kubitów może realizować 2^n równoległych obliczeń.\nDruga istotna koncepcja w obliczeniach kwantowych to pamięć.\nW klasycznych komputerach (np. 64-bitowy laptop) każda liczba może być reprezentowana w 64-bitowej formie (rozszerzenie reprezentacji 8-bitowej). Jeśli chcemy przechować 4 liczby w tej reprezentacji, potrzebujemy \\(4 \\times 64 = 256\\) bitów pamięci na twardym dysku. Generalnie, dla \\(M\\) liczb potrzebujemy \\(M \\times 64\\) bitów pamięci.\nW przypadku komputerów kwantowych operujących na \\(n\\)-kubitach, sytuacja wygląda inaczej. Możemy przechowywać \\(2^n\\) różnych współczynników, traktując taki stan jako pamięć. W odróżnieniu od klasycznej pamięci, gdzie ilość bitów pamięci jest liniowa w stosunku do liczby przechowywanych danych, pamięć realizowana na kubitach jest funkcją logarytmiczną od liczby liczb.\nPrzykładowo, dla \\(n\\)-kubitów, komputer kwantowy jest w stanie przechować \\(2^n\\) stanów, co jest równoważne \\(2^n\\) różnym współczynnikom. Tak więc, liczba kubitów potrzebnych do przechowania dużej ilości informacji rośnie znacznie wolniej niż liczba bitów w klasycznych komputerach.\nWspółczesne klasyczne komputery są bardzo zaawansowane i mogą zawierać dziesiątki terabajtów pamięci, co pozwala im na symulację niewielkich układów kwantowych. Największe klasyczne komputery są w stanie symulować układy do około 46 kubitów. Dla porównania, obecnie IBM oferuje komputery kwantowe oparte na 127 kubitach, a nawet rozwijają technologie dla układów z 1000 kubitami.\nPamięć w komputerach kwantowych jest znacznie bardziej efektywna w przechowywaniu informacji w porównaniu do klasycznych komputerów. Dzięki możliwości reprezentowania wielu stanów jednocześnie, komputery kwantowe oferują potencjalnie ogromne możliwości obliczeniowe przy znacznie mniejszych wymaganiach pamięciowych.\n\n\nKwantowa Korekcja Błędów (Quantum Error Correction)\nDekoherencja, czyli oddziaływanie kwantowego systemu z jego otoczeniem, może zniszczyć stan komputera kwantowego i wprowadzać błędy obliczeniowe. Aby zapewnić integralność obliczeń w komputerach kwantowych, konieczne jest zastosowanie technik korekcji błędów.\nKwantowa korekcja błędów (Quantum Error Correction) jest kluczowym obszarem badawczym w dziedzinie obliczeń kwantowych, który zajmuje się identyfikowaniem i korygowaniem błędów w systemach kwantowych. W przeciwieństwie do klasycznych systemów komputerowych, gdzie błędy mogą być łatwo korygowane, w przypadku komputerów kwantowych sytuacja jest bardziej złożona z powodu delikatnej natury stanów kwantowych oraz zjawisk takich jak superpozycja i splątanie.\nEra Noisy Intermediate-Scale Quantum (NISQ) oznacza, że obecne komputery kwantowe, mimo że są zaawansowane, wciąż są w fazie rozwoju i borykają się z problemami związanymi z błędami i stabilnością. Systemy NISQ są wystarczająco zaawansowane, by wykonywać pewne interesujące obliczenia kwantowe, ale nadal wymagają dalszych postępów w zakresie korekcji błędów oraz stabilności, aby mogły osiągnąć pełny potencjał.\nW praktyce, kwantowa korekcja błędów wymaga stosowania specjalnych kodów kwantowych, które pozwalają na detekcję i korekcję błędów bez bezpośredniego pomiaru stanów kwantowych. Kody te wprowadzają redundancję w reprezentacji informacji kwantowej, co pozwala na naprawę błędów i utrzymanie poprawności obliczeń.",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Komputery klasyczne i kwantowe"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#proces-obliczeń-kwantowych",
    "href": "lectures/wyklad1.html#proces-obliczeń-kwantowych",
    "title": "Komputery klasyczne i kwantowe",
    "section": "Proces obliczeń kwantowych",
    "text": "Proces obliczeń kwantowych\nW obliczeniach kwantowych cały proces można podzielić na trzy główne etapy:\n\nPrzygotowanie\n\nPrzygotowanie stanów kwantowych kubitów to pierwszy krok w procesie obliczeń kwantowych. W tym etapie tworzymy początkowy stan kubitów, który będzie podstawą dla dalszych operacji. Stan ten może być przygotowany na różne sposoby, w zależności od problemu i algorytmu, który chcemy zaimplementować. Przykładowo, kubity mogą być przygotowane w stanach podstawowych, stanach superpozycji lub w stanach splątanych.\n\nEwolucja\n\nEwolucja polega na stosowaniu bramek kwantowych, które transformują stan kubitów zgodnie z zaplanowanym algorytmem. Bramki kwantowe to odpowiedniki operacji logicznych w klasycznych komputerach, ale operują one na stanach kwantowych, wykorzystując zjawiska takie jak superpozycja i splątanie. Bramki kwantowe są reprezentowane przez macierze unitarnie, które przekształcają stany kubitów w czasie ewolucji obliczeń.\n\nPomiar i interpretacja wyników\n\nPo przeprowadzeniu ewolucji kwantowej następuje pomiar kubitów, który kończy obliczenia. Pomiar kwantowy “zapada” stan kubitu do jednego z możliwych wyników, co powoduje kolaps stanu kwantowego. Wyniki pomiaru są klasycznymi bitami, które można analizować i interpretować, aby uzyskać końcowy wynik obliczeń. Pomiar jest kluczowy, ponieważ to właśnie na podstawie wyników pomiarów uzyskujemy informacje, które są następnie analizowane w kontekście rozwiązania problemu.\n\n\nW codziennej interakcji z komputerem nie obserwujemy bezpośrednio tych etapów, ponieważ są one zautomatyzowane i wbudowane w działanie systemów komputerowych i programów. Dlatego często nie zauważamy świadomie tego schematu działania, mimo że jest on integralną częścią procesu obliczeń, zarówno klasycznych, jak i kwantowych. Piotr Gawron, Oscar Słowik - Rewolucja Stanu, Fantastyczne wprowadzenie do informatyki kwantowej.\n\nKażdy komputer kwantowy (lub koprocesor kwantowy) musi współpracować z układem klasycznym, aby realizować pełne obliczenia i operacje. Oto, jak ta integracja zazwyczaj wygląda:\n\nInterfejs Komunikacyjny\n\nKomputer kwantowy potrzebuje interfejsu do komunikacji z klasycznym komputerem. Interfejs ten umożliwia przesyłanie danych wejściowych do komputera kwantowego oraz odbieranie wyników obliczeń. Współczesne systemy często używają standardowych protokołów komunikacyjnych, takich jak TCP/IP, do przesyłania danych między układami klasycznymi a kwantowymi.\n\nPrzygotowanie Danych\n\nKlasyczny komputer przygotowuje dane wejściowe dla komputera kwantowego. Może to obejmować kodowanie danych w formacie odpowiednim dla kwantowego algorytmu oraz przygotowanie stanów kwantowych. Proces ten często wymaga przetworzenia i dostosowania danych do specyficznych wymagań obliczeń kwantowych.\n\nWykonanie Obliczeń\n\nKomputer kwantowy realizuje obliczenia, wykorzystując swoje qubity i bramki kwantowe. Operacje te są przeprowadzane zgodnie z algorytmami kwantowymi, które mogą wymagać precyzyjnego kontrolowania stanu qubitów i przeprowadzania skomplikowanych transformacji kwantowych.\n\nPomiar i interpretacja\n\nPo zakończeniu obliczeń kwantowych, wyniki są mierzone i interpretowane. Pomiar kwantowy powoduje kolaps stanu qubitów do jednego z możliwych wyników, który jest następnie przesyłany do klasycznego komputera.\n\nPostprocessing\n\nKlasyczny komputer przeprowadza dalszą obróbkę wyników, interpretując i analizując dane uzyskane z obliczeń kwantowych. Może to obejmować interpretację wyników, porównanie z oczekiwaniami oraz podejmowanie decyzji na podstawie uzyskanych wyników.\n\nWspółpraca i Synchronizacja\n\nWspółczesne systemy kwantowe często integrują komputery kwantowe jako koprocesory, które wspierają obliczenia klasyczne. Synchronizacja między komputerami kwantowymi a klasycznymi jest kluczowa dla efektywnego wykorzystania obu typów obliczeń i osiągnięcia optymalnych wyników.\nIntegracja komputerów kwantowych z klasycznymi umożliwia korzystanie z unikalnych właściwości obliczeń kwantowych przy jednoczesnym wykorzystaniu sprawdzonych technologii klasycznych, co pozwala na efektywne i wszechstronne podejście do rozwiązywania problemów obliczeniowych.",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Komputery klasyczne i kwantowe"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#quantum-machine-learning",
    "href": "lectures/wyklad1.html#quantum-machine-learning",
    "title": "Komputery klasyczne i kwantowe",
    "section": "Quantum Machine Learning",
    "text": "Quantum Machine Learning\n\nDane w QML\n\n\nCC - Classical data using classical computers, algorytmy inspirowane obliczeniami kwantowymi\nQC - Quantum data using classical (ML) computers. link1, link2, link3\nCQ - Classical data on qunatum computers. Na tym chcemy się skupić.\nQQ - Quantum data on quantum computers. Who knows?\n\n\n\nRealizacje problemów biznesowych na komputerach kwantowych\n\nSystemy obrony - kryptografia\nRigetti - przewidywanie pogody\nNASA (QuAIL) - Kontrola lotów kosmicznych\nAccenture - Finanse, logistyka, komunikacja i systemy bezpieczeństwa\nBASF - Obliczenia molekularne w chemii kwantowej.\nFord link\nVolkswagen link\nBMW link\nBoeing/Airbus\nGoldman Sach / JPMorgan\nDWave DWave and VW\nIBM Case study\nIBM 127 qubitów\nQuantum Natural Language Processing link\n\n\n\nDostęp do obliczeń kwantowych w chmurze\n\nIBM Quantum z wykorzystaniem biblioteki qiskit.\nPennylane z wykorzystaniem biblioteki pennylane.\nCirq Google z wykorzystaniem biblioteki cirq.\nD-Wave - Python\nXanadu - Pennylane Python library\nAmazon braket - AWS Python, Julia",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Komputery klasyczne i kwantowe"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html",
    "href": "lectures/wyklad5.html",
    "title": "Algorytmy kwantowego uczenia maszynowego QML",
    "section": "",
    "text": "Dziedziną łączącą klasyczne uczenie maszynowe i obliczenia kwantowe nazywamy kwantowym uczeniem maszynowym. QML powstało aby szybciej (czas trenowania modelu) i sprawniej (ewaluacja) rozwiązywać problemy uczenia maszynowego. Do tego celu chcemy wykorzystać procesory kwantowe oraz własności algorytmów kwantowych i ich przewagi nad klasycznymi odpowiednikami.\nDobre i uzyteczne procesory kwantowe, realizujące w pełni nasze oczekiwania to wciąz odległa przyszłość. Jednak bardzo szybko rozwija się dziedzina, która wskazuje jak uzywać aktualnych (słabych i zaszumionych) procesorów kwantowych z wykorzystaniem klasycznych optymalizatorów w podejściu hybrydowym. W podejściu tym komputery kwantowe mogą być uzywane i trenowane podobnie do sieci neuronowych. Mozemy np. kontrolować parametry fizyczne naszego układu kwantowego (natęzenie pola elektromagnetycznego, częstotliwość promienia laserowego), co pozwinno pozwolić rozwiązać probelmy analogicznie jak ma to miejsce w sieciach neuronowych. W bardziej rozszerzonym podejściu okazuje się, ze cały obwód kwantowy moze być kontrolowany za pomocą parametrów realizowanych w bramkach. Mozna go traktować jako rózniczkowalną funkcję. Automatyczne rózniczkowanie wykorzystywane jest w paradygmacie programowania Differentiable programming jak równiez w szeroko stosowanych sieciach neuronowych. Podejście to mozna wyrazic jako coś więcej niz sieci neuronowe. To paradygmat gdzie algorytmy nie są kodowane ale “uczące się”.\nDlatego idea trenowania komputerów kwantowych pozwala na więcej niz tylko realizacja modeli uczenia maszynowego. Trenowane obwody kwantowe mozna wykorzystać w chemii kwantowe, kwantowej optymalizacji, projektowaniu algorytmów kwantowych, kwantowej korekcji błędów czy zrozumienia układów fizycznych.",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Algorytmy kwantowego uczenia maszynowego QML"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#pqc",
    "href": "lectures/wyklad5.html#pqc",
    "title": "Algorytmy kwantowego uczenia maszynowego QML",
    "section": "PQC",
    "text": "PQC",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Algorytmy kwantowego uczenia maszynowego QML"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#kwantowe-algorytmy-wariacyjne",
    "href": "lectures/wyklad5.html#kwantowe-algorytmy-wariacyjne",
    "title": "Algorytmy kwantowego uczenia maszynowego QML",
    "section": "Kwantowe Algorytmy Wariacyjne",
    "text": "Kwantowe Algorytmy Wariacyjne\nVariational Quantum Algorithms (VQA) czyli kwantowe algorytmy wariacyjne nalezą do klasy algorytmów hybrydowych. Oznacza to, ze do ich realizacji wykorzystamy zarówno procesor kwantowy jak i klasyczne algorytmy optymalizacyjne.",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Algorytmy kwantowego uczenia maszynowego QML"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#quantum-neural-networks",
    "href": "lectures/wyklad5.html#quantum-neural-networks",
    "title": "Algorytmy kwantowego uczenia maszynowego QML",
    "section": "Quantum Neural Networks",
    "text": "Quantum Neural Networks",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Algorytmy kwantowego uczenia maszynowego QML"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#quantum-support-vector-classification",
    "href": "lectures/wyklad5.html#quantum-support-vector-classification",
    "title": "Algorytmy kwantowego uczenia maszynowego QML",
    "section": "Quantum Support Vector Classification",
    "text": "Quantum Support Vector Classification",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Algorytmy kwantowego uczenia maszynowego QML"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#quantum-approximation-optimization-algorithm-dla-problemów-qubo",
    "href": "lectures/wyklad5.html#quantum-approximation-optimization-algorithm-dla-problemów-qubo",
    "title": "Algorytmy kwantowego uczenia maszynowego QML",
    "section": "Quantum Approximation Optimization Algorithm dla problemów QUBO",
    "text": "Quantum Approximation Optimization Algorithm dla problemów QUBO",
    "crumbs": [
      "Sylabus",
      "Wykłady",
      "Algorytmy kwantowego uczenia maszynowego QML"
    ]
  },
  {
    "objectID": "check/cw1_old_qiskit.html",
    "href": "check/cw1_old_qiskit.html",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "",
    "text": "import numpy as np\n\ndef measure_state(state, num_meas):\n    # assert state[0]* np.conj(state[0]) + state[1]* np.conj(state[1]) == 1\n\n    # COMPUTE THE MEASUREMENT OUTCOME PROBABILITIES\n    p_0 = state[0] * np.conj(state[0])\n    p_1 = state[1] * np.conj(state[1])\n    # RETURN A LIST OF SAMPLE MEASUREMENT OUTCOMES\n    return np.random.choice(2,num_meas, p=[p_0,p_1])\nmeasure_state(np.array([0.8, 0.6]),5)\n\nU = np.array([[1, 1], [1, -1]]) / np.sqrt(2)\nU@np.array([0.8, 0.6])\n\narray([0.98994949, 0.14142136])\nThe other important libs.\nfrom qiskit import  __qiskit_version__\nprint(__qiskit_version__)\n\nimport qiskit.tools.jupyter\n\n%qiskit_version_table\nimport numpy as np\nnp.set_printoptions(precision=3, suppress=True)"
  },
  {
    "objectID": "check/cw1_old_qiskit.html#qiskit-podstawy",
    "href": "check/cw1_old_qiskit.html#qiskit-podstawy",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "Qiskit podstawy",
    "text": "Qiskit podstawy\nTworzenie rejestrów:\n\nkwantowego QuantumRegister - do inicjalizowania kubitów. Kubity domyślnie inicjalizowane są w stanie \\(|0\\rangle\\)\nklasycznego ClassicalRegister do przechowywania wyników pomiarów kubitów. Po pomiarze otrzymywany wynik zawsze jest binarny \\(\\{0,1\\}\\).\n\n\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n\nOba rejestry wykorzystywane będą do generowania obwodów kwantowych QuantumCircuit.\nWszystkie podstawowe obiekty dostępne są bezpośrednio w bibliotece qiskit.\n\nqreq = QuantumRegister(4) # rejest kwantowy z 4 qubitami\n\n\ncreg = ClassicalRegister(4) # rejestr klasyczny z 4 bitami\n\n\ncircuit = QuantumCircuit(qreq, creg) # obwód kwantowy z 4 qubitami i 4 bitami\n\n\ncircuit.draw('mpl') # funkcja rysująca obwód\n\n\noutput = QuantumRegister(1) # inny rejestr kwantowy z 1 qubitem\n\n\ncircuit2 = QuantumCircuit(qreq, output, creg)\n\n\ncircuit2.draw(\"mpl\")\n\n\ncircuit3 = QuantumCircuit(qreq)\n\n\ncircuit3.draw('mpl')\n\n\ncircuit4 = QuantumCircuit(3,3)\ncircuit4.draw(\"mpl\")\n\n\nfrom qiskit_aer.primitives import Sampler\n\nfrom qiskit import QuantumCircuit\nfrom qiskit.visualization import plot_histogram\n\nbell = QuantumCircuit(2)\nbell.h(0)\nbell.measure_all()\n \n# execute the quantum circuit\nquasi_dists = Sampler().run(bell, shots=1000).result().quasi_dists[0]\nprint(quasi_dists)\n\n\nplot_histogram(quasi_dists)"
  },
  {
    "objectID": "check/cw1_old_qiskit.html#podstawowe-backendy",
    "href": "check/cw1_old_qiskit.html#podstawowe-backendy",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "Podstawowe backendy",
    "text": "Podstawowe backendy\nWykonanie obwodu moze być realizowane zarówno na prawidziwym komputerze kwantowym jak i na lokalnym, klasycznym symulatorze. Większość naszych zadań przeprowadzanych będzie z wykorzystaniem symulatora Aer.\n\nfrom qiskit import Aer \n\nAer.backends()\n\nPodstawowym symulatorem na którym mozemy w pełni uruchomić kod obwodu jest qasm_simulator. Uruchamia on cały obwód i zapisuje wyniki do rejestru klasycznego. Po wielokrotnym uruchomieniu obwodu mozemy sprawdzić równiez statystyki otrzymanych wyników.\n\nPomiar w obwodzie i wielokrotne uruchamianie układu\n\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n\nqreg = QuantumRegister(2)\ncreg = ClassicalRegister(2)\n# utworzenie obwodu kwantowego z 2 qubitami i 2 bitami\ncircuit = QuantumCircuit(qreg, creg)\ncircuit.h(qreg[0]) # działamy jakąś bramką na pierwszym qubicie\ncircuit.measure(qreg, creg) # dokunujemy pomiaru\n\n# zdefiniowanie symulatora\nsimulator = Aer.get_backend('qasm_simulator')\n# definicja zadania do wykonania\njob = execute(circuit, simulator, shots=1000)\n\nprint(job.job_id())\n# wyciągnięcie wyników i statystyk\ncounts = job.result().get_counts(circuit)\nprint(counts)\n\nWizualizacja otrzymanych wyników realizowana metodą plot_histogram.\n\nfrom qiskit.visualization import plot_histogram\ndisplay(plot_histogram(counts))"
  },
  {
    "objectID": "check/cw1_old_qiskit.html#tworzenie-stanu-jednokubitowego",
    "href": "check/cw1_old_qiskit.html#tworzenie-stanu-jednokubitowego",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "Tworzenie stanu jednokubitowego",
    "text": "Tworzenie stanu jednokubitowego\n\\[\n\\ket{\\psi}=\\ket{0}\n\\]\nDo inspekcji stanu układu (bez jego pomiaru) mozemy uzyć backend statevector_simulator.\n\nqr = QuantumRegister(1)\nqc = QuantumCircuit(qr)\n\n# klasyczny symulator pozwala zobaczyc stan\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector() # wynik w postaci wektora stanu\nprint(state)\n\n\nstate.draw('latex') # metoda wypisująca wektor stanu w latexu\n\n\nfrom qiskit.visualization import plot_bloch_multivector\nplot_bloch_multivector(result.get_statevector())\n\n\nqr = QuantumRegister(1)\nqc = QuantumCircuit(qr)\nqc.h(qr[0])\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\nstate.draw('latex')\n\n\nfrom qiskit.visualization import plot_bloch_multivector\nplot_bloch_multivector(result.get_statevector())\n\n\ninicjalizacja stanu\n\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(1)\ninitial_state = [0,1]\nqc.initialize(initial_state, 0)\nqc.draw('mpl')\n\n\nfrom qiskit import Aer, execute\nbackend = Aer.get_backend('statevector_simulator')\nresult = execute(qc, backend).result()\nstate = result.get_statevector()\nstate.draw('latex')\n\n\ninitial_state = [1,1]\nqc = QuantumCircuit(1)\nqc.initialize(initial_state, 0)\nresult = execute(qc, backend).result().get_statevector()\nresult.draw('latex')\n\n\nfrom math import sqrt\ninitial_state = [1/sqrt(2),1/sqrt(2)]\nqc = QuantumCircuit(1)\nqc.initialize(initial_state, 0)\nresult = execute(qc, backend).result().get_statevector()\nresult.draw('latex')\n\n\nfrom math import sqrt\ninitial_state = [1/2,sqrt(3)/2]\nqc = QuantumCircuit(1)\nqc.initialize(initial_state, 0)\nresult = execute(qc, backend).result().get_statevector()\nresult.draw('latex')\n\n\nfrom math import pi, cos, sin \ndef get_state(theta):\n    return [cos(theta/2), sin(theta/2)]\n\ntheta = -pi/2\n\nqc = QuantumCircuit(1)\nqc.initialize(get_state(theta), 0)\nbackend = Aer.get_backend('statevector_simulator')\nresult = execute(qc, backend).result().get_statevector()\nresult.draw('latex')\n\n\nfrom qiskit.visualization import plot_histogram\nresult = execute(qc, backend).result().get_counts()\nplot_histogram(result)"
  },
  {
    "objectID": "check/cw1_old_qiskit.html#tworzenie-stanu-dwukubitowego",
    "href": "check/cw1_old_qiskit.html#tworzenie-stanu-dwukubitowego",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "Tworzenie stanu dwukubitowego",
    "text": "Tworzenie stanu dwukubitowego\n\\[\n\\ket{00}, \\ket{01}, \\ket{10}, \\ket{11}\n\\]\n\nqr = QuantumRegister(2)\nqc = QuantumCircuit(qr)\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\nstate.draw('latex')\n\n\nqr = QuantumRegister(2)\nqc = QuantumCircuit(qr)\nqc.h(qr[0])\nqc.h(qr[1])\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\nstate.draw('latex')\n\n\nfrom qiskit.visualization import plot_bloch_multivector\nplot_bloch_multivector(result.get_statevector())\n\n\nqr = QuantumRegister(2)\nqc = QuantumCircuit(qr)\nqc.h(qr[0])\nqc.cx(0,1)\n\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\n\n\nqc.draw('mpl')\n\n\nstate.draw('latex')\n\n\nfrom qiskit.visualization import plot_bloch_multivector\nplot_bloch_multivector(result.get_statevector())"
  },
  {
    "objectID": "check/cw1_old_qiskit.html#tworzenie-stanu-trzy-kubitowego",
    "href": "check/cw1_old_qiskit.html#tworzenie-stanu-trzy-kubitowego",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "Tworzenie stanu trzy-kubitowego",
    "text": "Tworzenie stanu trzy-kubitowego\n\\[\n\\ket{000}, \\ket{001}, \\ket{010}, \\ket{011}, \\ket{100}, \\ket{101}, \\ket{110}, \\ket{111}\\]\n\nqr = QuantumRegister(3)\nqc = QuantumCircuit(qr)\n# qc.x(qr[0]) \n# qc.x(qr[1])\n\n# klasyczny symulator pozwala zobaczyc stan\nbackend = Aer.get_backend('statevector_simulator')\njob=execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\n\nUruchom powyższy kod usuwajac poszczegolne komentarze i sprawdz wynik.\n\n# uruchom w środowisku IBM Quantum Experience\nfrom qiskit_ibm_provider import IBMProvider\n\nIBMProvider.save_account(token=MY_API_TOKEN)\nprovider = IBMProvider()\n\n# Create a circuit\nqc = QuantumCircuit(2)\nqc.h(0)\nqc.cx(0, 1)\nqc.measure_all()\n\n# Select a backend.\nbackend = provider.get_backend(\"ibmq_qasm_simulator\")\n\n# Transpile the circuit\ntranspiled = transpile(qc, backend=backend)\n\n# Submit a job.\njob = backend.run(transpiled)\n# Get results.\nprint(job.result().get_counts())\n\nWięcej informacji znajdziesz tutaj\n\nfrom qiskit.tools.visualization import circuit_drawer\n\nq = QuantumRegister(1)\nc = ClassicalRegister(1)\ncircuit = QuantumCircuit(q, c)\ncircuit.measure(q, c)\ncircuit_drawer(circuit)"
  },
  {
    "objectID": "lectures/cw_w5.html#klasyczna-sieć-neuronowa",
    "href": "lectures/cw_w5.html#klasyczna-sieć-neuronowa",
    "title": "Trenowanie sieci neuronowej PyTorch",
    "section": "klasyczna sieć neuronowa",
    "text": "klasyczna sieć neuronowa\n\nclass NN(torch.nn.Module):\n\n    def __init__(self, N_INPUT: int, N_OUTPUT: int):\n        super().__init__()\n        self.clayer1 = torch.nn.Linear(N_INPUT, 8)\n        self.clayer2 = torch.nn.Linear(8,4)\n        self.clayer3 = torch.nn.Linear(4, N_OUTPUT)\n\n    def forward(self, x):\n        x = self.clayer1(x)\n        x = torch.relu(x)\n        x = self.clayer2(x)\n        x = torch.relu(x)\n        x = self.clayer3(x)\n        return x\n\nmodel = NN(1,1)\n\nlearning_rate=1e-3\noptimiser = torch.optim.Adam(model.parameters(), lr=learning_rate)\nepochs = 100\n\n\ndef mse(y, y_pred) -&gt; torch.Tensor:\n    return torch.mean((y-y_pred)**2)\n\nlosses = []\n\ndef callback(model, loss):\n    losses.append(loss.item())\n\n    clear_output(wait=True)\n    prediction = model(x).detach()\n    plt.figure(figsize=(6,2.5))\n    plt.plot(x[:,0].detach(), torch.sin(x)[:,0].detach(), label=\"Exact solution\", color=\"tab:grey\", alpha=0.6)\n    plt.plot(x[:,0].detach(), prediction[:,0], label=\"Classical solution\", color=\"tab:green\")\n    plt.title(f\"Training step {len(losses)}\")\n    plt.legend()\n    plt.show()\n\n    plt.figure(figsize=(6,2.5))\n    plt.title('Lossfn Visualised')\n    plt.plot(losses)\n    plt.show()\n\n\ndef train(X,Y, model, optimiser, epochs, lossfn, callback = None):\n    for epoch in range(epochs):\n        optimiser.zero_grad()\n        prediction = model(X)\n\n        loss = lossfn(Y, prediction)\n        loss.backward()\n        optimiser.step()\n\n        if callback != None:\n            callback(model, loss)\n\n\nx_train = x.requires_grad_(True)\n\ntrain(x_train, y, model, optimiser, 100, mse, callback)"
  }
]