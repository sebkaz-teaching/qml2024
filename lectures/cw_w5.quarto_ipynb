{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Trenowanie sieci neuronowej PyTorch\n"
      ],
      "id": "c4bccf07"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pennylane as qml\n",
        "import torch\n",
        "import pandas as pd \n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "from IPython.display import clear_output\n",
        "\n",
        "N_QUBITS = 2\n",
        "\n",
        "torch.manual_seed(1234)\n",
        "\n",
        "# DANE \n",
        "\n",
        "x = torch.linspace(0,10,500).view(-1,1)\n",
        "y = torch.sin(x)\n",
        "y = y + 0.1*(torch.rand(500).view(-1,1)-0.5)\n",
        "\n",
        "plt.figure(figsize=(8,4))\n",
        "plt.plot(x, torch.sin(x).view(-1,1), color=\"tab:grey\", alpha=0.6, label=\"sin(x)\")\n",
        "plt.scatter(x,y, label=\"dane treningowe\")\n",
        "plt.xlabel('x')\n",
        "plt.ylabel('y')\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "8731d275",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## klasyczna sieÄ‡ neuronowa\n"
      ],
      "id": "5707b788"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class NN(torch.nn.Module):\n",
        "\n",
        "    def __init__(self, N_INPUT: int, N_OUTPUT: int):\n",
        "        super().__init__()\n",
        "        self.clayer1 = torch.nn.Linear(N_INPUT, 8)\n",
        "        self.clayer2 = torch.nn.Linear(8,4)\n",
        "        self.clayer3 = torch.nn.Linear(4, N_OUTPUT)\n",
        "\n",
        "    def forward(self, x):\n",
        "        x = self.clayer1(x)\n",
        "        x = torch.relu(x)\n",
        "        x = self.clayer2(x)\n",
        "        x = torch.relu(x)\n",
        "        x = self.clayer3(x)\n",
        "        return x\n",
        "\n",
        "model = NN(1,1)\n",
        "\n",
        "learning_rate=1e-3\n",
        "optimiser = torch.optim.Adam(model.parameters(), lr=learning_rate)\n",
        "epochs = 100\n",
        "\n",
        "\n",
        "def mse(y, y_pred) -> torch.Tensor:\n",
        "    return torch.mean((y-y_pred)**2)\n",
        "\n",
        "def special_loss_fn(y, y_pred) -> torch.Tensor:\n",
        "    return mse(y, y_pred) + torch.mean((y_pred - torch.sin(x))**2)\n",
        "\n",
        "\n",
        "losses = []\n",
        "\n",
        "def callback(model, loss):\n",
        "    losses.append(loss.item())\n",
        "\n",
        "    clear_output(wait=True)\n",
        "    prediction = model(x).detach()\n",
        "    plt.figure(figsize=(6,2.5))\n",
        "    plt.plot(x[:,0].detach(), torch.sin(x)[:,0].detach(), label=\"Exact solution\", color=\"tab:grey\", alpha=0.6)\n",
        "    plt.plot(x[:,0].detach(), prediction[:,0], label=\"Classical solution\", color=\"tab:green\")\n",
        "    plt.title(f\"Training step {len(losses)}\")\n",
        "    plt.legend()\n",
        "    plt.show()\n",
        "\n",
        "    plt.figure(figsize=(6,2.5))\n",
        "    plt.title('Lossfn Visualised')\n",
        "    plt.plot(losses)\n",
        "    plt.show()\n",
        "\n",
        "\n",
        "def train(X,Y, model, optimiser, epochs, lossfn, callback = None):\n",
        "    for epoch in range(epochs):\n",
        "        optimiser.zero_grad()\n",
        "        prediction = model(X)\n",
        "\n",
        "        loss = lossfn(Y, prediction)\n",
        "        loss.backward()\n",
        "        optimiser.step()\n",
        "\n",
        "        if callback != None:\n",
        "            callback(model, loss)\n",
        "\n",
        "\n",
        "x_train = x.requires_grad_(True)\n",
        "\n",
        "train(x_train, y, model, optimiser, 1000, special_loss_fn, callback)"
      ],
      "id": "5ca91729",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/seba/Documents/GitHub/qml2024/venv/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}