{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Trenowanie sieci neuronowej PyTorch\n"
      ],
      "id": "032909a1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import torch\n",
        "import pandas as pd \n",
        "import matplotlib.pyplot as plt\n",
        "from IPython.display import clear_output\n",
        "\n",
        "torch.manual_seed(1234)\n",
        "\n",
        "# DANE \n",
        "x = torch.linspace(0,10,500).view(-1,1)\n",
        "y = torch.sin(x)\n",
        "y = y + 0.1*(torch.rand(500).view(-1,1)-0.5)\n",
        "\n",
        "plt.figure(figsize=(8,4))\n",
        "plt.plot(x, torch.sin(x).view(-1,1), color=\"tab:grey\", alpha=0.6, label=\"sin(x)\")\n",
        "plt.scatter(x,y, label=\"dane treningowe\")\n",
        "plt.xlabel('x')\n",
        "plt.ylabel('y')\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "d85b68f6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## klasyczna sieć neuronowa\n"
      ],
      "id": "e8b9fc8a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class SinusEstimator(torch.nn.Module):\n",
        "\n",
        "    def __init__(self, N_INPUT: int, N_OUTPUT: int):\n",
        "        super(SinusEstimator,self).__init__()\n",
        "        self.layers = torch.nn.Sequential(\n",
        "            torch.nn.Linear(N_INPUT, 64),\n",
        "            torch.nn.ReLU(),\n",
        "            torch.nn.Linear(64,32),\n",
        "            torch.nn.ReLU(),\n",
        "            torch.nn.Linear(32,16),\n",
        "            torch.nn.Tanh(),\n",
        "            torch.nn.Linear(16,N_OUTPUT)\n",
        "        )\n",
        "\n",
        "\n",
        "    def forward(self, x):\n",
        "        x = self.layers(x)\n",
        "        return x\n",
        "\n",
        "model = SinusEstimator(1,1)\n",
        "\n",
        "learning_rate=0.001\n",
        "optimiser = torch.optim.Adam(model.parameters(), lr=learning_rate)\n",
        "criterion = torch.nn.MSELoss()\n",
        "\n",
        "losses = []\n",
        "\n",
        "def callback(model, loss):\n",
        "    losses.append(loss.item())\n",
        "\n",
        "    clear_output(wait=True)\n",
        "    prediction = model(x).detach()\n",
        "    plt.figure(figsize=(6,2.5))\n",
        "    plt.plot(x[:,0].detach(), torch.sin(x)[:,0].detach(), label=\"Exact solution\", color=\"tab:grey\", alpha=0.6)\n",
        "    plt.plot(x[:,0].detach(), prediction[:,0], label=\"Classical solution\", color=\"tab:green\")\n",
        "    plt.title(f\"Training step {len(losses)}\")\n",
        "    plt.legend()\n",
        "    plt.show()\n",
        "\n",
        "    plt.figure(figsize=(6,2.5))\n",
        "    plt.title('Lossfn Visualised')\n",
        "    plt.plot(losses)\n",
        "    plt.show()\n",
        "\n",
        "\n",
        "def train(X,Y, model, optimiser, epochs, lossfn, callback = None):\n",
        "    for epoch in range(epochs):\n",
        "        model.train()\n",
        "        prediction = model(X)\n",
        "        loss = lossfn(prediction, Y)\n",
        "\n",
        "        optimiser.zero_grad()\n",
        "        loss.backward()\n",
        "        optimiser.step()\n",
        "        model.eval()\n",
        "        if callback != None:\n",
        "            callback(model, loss)\n",
        "\n",
        "x_train = x.requires_grad_(True)\n",
        "\n",
        "train(x_train, y, model, optimiser, 500, criterion, callback)"
      ],
      "id": "3d9aadf7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Sprawdź czy modyfikacja funkcji straty pomoze polepszyć wynik\n",
        "\n",
        "\n",
        "def mse(y, y_pred) -> torch.Tensor:\n",
        "    return torch.mean((y-y_pred)**2)\n",
        "\n",
        "def special_loss_fn(y, y_pred) -> torch.Tensor:\n",
        "    return mse(y, y_pred) + torch.mean((y_pred - torch.sin(x))**2)\n",
        "\n",
        "train(x_train, y, model, optimiser, 500, special_loss_fn, callback)"
      ],
      "id": "2e78697c"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/seba/Documents/GitHub/qml2024/venv/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}