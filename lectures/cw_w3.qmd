
Solution l.1.1


```{python}
import numpy as np

ket_0 = np.array([1, 0])
ket_1 = np.array([0, 1])


def normalize_state(alpha, beta):
    """Compute a normalized quantum state given arbitrary amplitudes.

    Args:
        alpha (complex): The amplitude associated with the |0> state.
        beta (complex): The amplitude associated with the |1> state.

    Returns:
        np.array[complex]: A vector (numpy array) with 2 elements that represents
        a normalized quantum state.
    """
    ##################
    # YOUR CODE HERE #
    ##################
    kappa = alpha * np.conj(alpha) + beta * np.conj(beta)
    N = 1/(np.sqrt(kappa))
    

    # CREATE A VECTOR [a', b'] BASED ON alpha AND beta SUCH THAT |a'|^2 + |b'|^2 = 1
    solution = np.array([alpha * N, beta * N])
    # RETURN A VECTOR
    return solution 

state = np.array([0.8, 0.6])
normalize_state(state[0],state[1])

```

Solution l.1.2
```{python}

import numpy as np

def inner_product(state_1, state_2):
    """Compute the inner product between two states.

    Args:
        state_1 (np.array[complex]): A normalized quantum state vector
        state_2 (np.array[complex]): A second normalized quantum state vector

    Returns:
        complex: The value of the inner product <state_1 | state_2>.
    """

    solution = state_2[0] * np.conj(state_1[0]) +  state_2[1] * np.conj(state_1[1])

    # COMPUTE AND RETURN THE INNER PRODUCT

    return solution


# Test your results with this code
ket_0 = np.array([1, 0])
ket_1 = np.array([0, 1])

print(f"<0|0> = {inner_product(ket_0, ket_0)}")
print(f"<0|1> = {inner_product(ket_0, ket_1)}")
print(f"<1|0> = {inner_product(ket_1, ket_0)}")
print(f"<1|1> = {inner_product(ket_1, ket_1)}")

```